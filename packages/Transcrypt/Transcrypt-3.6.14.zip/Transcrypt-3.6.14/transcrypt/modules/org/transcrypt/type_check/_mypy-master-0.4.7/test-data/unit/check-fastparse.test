[case testFastParseSyntaxError]
# flags: --fast-parser
1 +  # E: invalid syntax

[case testFastParseTypeCommentSyntaxError]
# flags: --fast-parser
x = None # type: a : b  # E: syntax error in type comment

[case testFastParseInvalidTypeComment]
# flags: --fast-parser
x = None # type: a + b  # E: invalid type comment

-- Function type comments are attributed to the function def line.
-- This happens in both parsers.
[case testFastParseFunctionAnnotationSyntaxError]
# flags: --fast-parser
def f():  # E: syntax error in type comment
  # type: None -> None
  pass

[case testFastParseInvalidFunctionAnnotation]
# flags: --fast-parser
def f(x):  # E: invalid type comment
  # type: (a + b) -> None
  pass

[case testFastParseProperty]
# flags: --fast-parser
class C:
  @property
  def x(self) -> str: pass
  @x.setter
  def x(self, value: str) -> None: pass
[builtins fixtures/property.pyi]

[case testFastParseConditionalProperty]
# flags: --fast-parser
class C:
  if bool():
    @property
    def x(self) -> str: pass
    @x.setter
    def x(self, value: str) -> None: pass
[builtins fixtures/property.pyi]

[case testFastParsePerArgumentAnnotations]
# flags: --fast-parser
class A: pass
class B: pass
class C: pass
class D: pass
class E: pass
class F: pass
def f(a,        # type: A
      b = None, # type: B
      *args,    # type: C
      d = None, # type: D
      e,        # type: E
      **kwargs  # type: F
      ):
    reveal_type(a)      # E: Revealed type is '__main__.A'
    reveal_type(b)      # E: Revealed type is '__main__.B'
    reveal_type(args)   # E: Revealed type is 'builtins.tuple[__main__.C]'
    reveal_type(d)      # E: Revealed type is '__main__.D'
    reveal_type(e)      # E: Revealed type is '__main__.E'
    reveal_type(kwargs) # E: Revealed type is 'builtins.dict[builtins.str, __main__.F]'
[builtins fixtures/dict.pyi]
[out]

[case testFastParsePerArgumentAnnotationsWithReturn]
# flags: --fast-parser
class A: pass
class B: pass
class C: pass
class D: pass
class E: pass
class F: pass
def f(a,        # type: A
      b = None, # type: B
      *args,    # type: C
      d = None, # type: D
      e,        # type: E
      **kwargs  # type: F
      ):
      # type: (...) -> int
    reveal_type(a)      # E: Revealed type is '__main__.A'
    reveal_type(b)      # E: Revealed type is '__main__.B'
    reveal_type(args)   # E: Revealed type is 'builtins.tuple[__main__.C]'
    reveal_type(d)      # E: Revealed type is '__main__.D'
    reveal_type(e)      # E: Revealed type is '__main__.E'
    reveal_type(kwargs) # E: Revealed type is 'builtins.dict[builtins.str, __main__.F]'
    return "not an int"  # E: Incompatible return value type (got "str", expected "int")
[builtins fixtures/dict.pyi]
[out]

[case testFastParsePerArgumentAnnotationsWithAnnotatedBareStar]
# flags: --fast-parser
def f(*, # type: int  # E: bare * has associated type comment
      x  # type: str
      ):
      # type: (...) -> int
    pass
[builtins fixtures/dict.pyi]
[out]

[case testFastParsePerArgumentAnnotationsWithReturnAndBareStar]
# flags: --fast-parser
def f(*,
      x  # type: str
      ):
      # type: (...) -> int
    reveal_type(x) # E: Revealed type is 'builtins.str'
    return "not an int"  # E: Incompatible return value type (got "str", expected "int")
[builtins fixtures/dict.pyi]
[out]

[case testFastParsePerArgumentAnnotations_python2]
# flags: --fast-parser
class A: pass
class B: pass
class C: pass
class D: pass
def f(a,        # type: A
      b = None, # type: B
      *args     # type: C
      # kwargs not tested due to lack of 2.7 dict fixtures
      ):
    reveal_type(a)      # E: Revealed type is '__main__.A'
    reveal_type(b)      # E: Revealed type is '__main__.B'
    reveal_type(args)   # E: Revealed type is 'builtins.tuple[__main__.C]'
[builtins fixtures/dict.pyi]
[out]

[case testFastParsePerArgumentAnnotationsWithReturn_python2]
# flags: --fast-parser
class A: pass
class B: pass
class C: pass
class D: pass
def f(a,        # type: A
      b = None, # type: B
      *args     # type: C
      # kwargs not tested due to lack of 2.7 dict fixtures
      ):
      # type: (...) -> int
    reveal_type(a)      # E: Revealed type is '__main__.A'
    reveal_type(b)      # E: Revealed type is '__main__.B'
    reveal_type(args)   # E: Revealed type is 'builtins.tuple[__main__.C]'
    return "not an int"  # E: Incompatible return value type (got "str", expected "int")
[builtins fixtures/dict.pyi]
[out]

[case testFasterParseTooManyArgumentsAnnotation]
# flags: --fast-parser
def f():  # E: Type signature has too many arguments
    # type: (int) -> None
    pass

[case testFasterParseTooFewArgumentsAnnotation]
# flags: --fast-parser
def f(x):  # E: Type signature has too few arguments
    # type: () -> None
    pass

[case testFasterParseTypeCommentError_python2]
# flags: --fast-parser
from typing import Tuple
def f(a):
    # type: (Tuple(int, int)) -> int
    pass
[out]
main:3: error: invalid type comment

[case testFastParseMatMul]
# flags: --fast-parser
from typing import Any
x = None  # type: Any
x @ 1
x @= 1

[case testIncorrectTypeCommentIndex]
# flags: --fast-parser
from typing import Dict
x = None # type: Dict[x: y]
[out]
main:3: error: syntax error in type comment

[case testPrintStatementTrailingCommaFastParser_python2]
# flags: --fast-parser
print 0,
print 1, 2,

[case testFastParserShowsMultipleErrors]
def f(x):  # E: Type signature has too few arguments
    # type: () -> None
    pass
def g():  # E: Type signature has too many arguments
    # type: (int) -> None
    pass

[case testFastParseMalformedAssert]
# flags: --fast-parser
assert 1, 2
assert (1, 2)  # W: Assertion is always true, perhaps remove parentheses?
assert (1, 2), 3  # W: Assertion is always true, perhaps remove parentheses?
assert ()
assert (1,)  # W: Assertion is always true, perhaps remove parentheses?

[case testFastParseAssertMessage]
# flags: --fast-parser
assert 1
assert 1, 2
assert 1, 1+2
assert 1, 1+'test'  # E: Unsupported operand types for + ("int" and "str")
assert 1, f()  # E: Name 'f' is not defined

[case testFastParserConsistentFunctionTypes]
# flags: --fast-parser
def f(x, y, z):
  # type: (int, int, int) -> int
  pass

def f(x,  # type: int  # E: Function has duplicate type signatures
      y,  # type: int
      z   # type: int
    ):
    # type: (int, int, int) -> int
    pass

def f(x,  # type: int
      y,  # type: int
      z   # type: int
    ):
    # type: (...) -> int
    pass

def f(x, y, z):
  # type: (int, int, int) -> int
  pass

def f(x) -> int:  # E: Function has duplicate type signatures
  # type: (int) -> int
  pass

def f(x: int, y: int, z: int):
  # type: (...) -> int
  pass

def f(x: int):  # E: Function has duplicate type signatures
  # type: (int) -> int
  pass

[case testFastParserDuplicateNames]
# flags: --fast-parser
def f(x, y, z):
  pass

def g(x, y, x):  # E: duplicate argument 'x' in function definition
  pass

def h(x, y, *x):  # E: duplicate argument 'x' in function definition
  pass

def i(x, y, *z, **z):  # E: duplicate argument 'z' in function definition
  pass

def j(x: int, y: int, *, x: int = 3):  # E: duplicate argument 'x' in function definition
  pass

def k(*, y, z, y):  # E: duplicate argument 'y' in function definition
  pass

lambda x, y, x: ...  # E: duplicate argument 'x' in function definition

[case testFastParserDuplicateNames_python2]
# flags: --fast-parser
def f(x, y, z):
  pass

def g(x, y, x):  # E: duplicate argument 'x' in function definition
  pass

def h(x, y, *x):  # E: duplicate argument 'x' in function definition
  pass

def i(x, y, *z, **z):  # E: duplicate argument 'z' in function definition
  pass

def j(x, (y, y), z):  # E: duplicate argument 'y' in function definition
  pass

def k(x, (y, x)):  # E: duplicate argument 'x' in function definition
  pass

def l((x, y), (z, x)):  # E: duplicate argument 'x' in function definition
  pass

def m(x, ((x, y), z)):  # E: duplicate argument 'x' in function definition
  pass

lambda x, (y, x): None  # E: duplicate argument 'x' in function definition
