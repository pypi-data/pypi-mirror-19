//DO NOT EDIT THIS FILE! (Generated from template: coeff_template.c using Mako python templating engine)

//#include <math.h>
#include "power.c"

// solve shifted first order coeff
// token_coeff[wy]

// we only have integer exponents in pow, use specialized verion:
#define pow(arg1, arg2) power(arg1, arg2)
#define WY 1
void poly_coeff1(const double * const restrict x,
			 const double * const restrict y,
			 double * const restrict c, 
			 const int nx){
#pragma omp parallel for
    for (int i=0; i < (nx-1); ++i){
	const double x1 = x[i+1]-x[i];
	c[i*2*WY+0] = y[0+i*WY];
	c[i*2*WY+1] = (-y[0+i*WY] + y[0+(i+1)*WY])/x1;
    }
    const int i = nx-1;
    const double x1 = x[i]-x[i-1];
    c[i*2*WY+0] = y[0+(i)*WY];
    c[i*2*WY+1] = (-y[0+(i-1)*WY] + y[0+(i)*WY])/x1;
}
#undef WY
#define WY 2
void poly_coeff2(const double * const restrict x,
			 const double * const restrict y,
			 double * const restrict c, 
			 const int nx){
#pragma omp parallel for
    for (int i=0; i < (nx-1); ++i){
	const double x1 = x[i+1]-x[i];
	const double cse0 = y[1+i*WY] + y[1+(i+1)*WY];
	c[i*2*WY+0] = y[0+i*WY];
	c[i*2*WY+1] = y[1+i*WY];
	c[i*2*WY+2] = (-x1*(cse0 + y[1+i*WY]) - 3*y[0+i*WY] + 3*y[0+(i+1)*WY])/pow(x1, 2);
	c[i*2*WY+3] = (cse0*x1 + 2*y[0+i*WY] - 2*y[0+(i+1)*WY])/pow(x1, 3);
    }
    const int i = nx-1;
    const double x1 = x[i]-x[i-1];
    c[i*2*WY+0] = y[0+(i)*WY];
    c[i*2*WY+1] = y[1+(i)*WY];
    c[i*2*WY+2] = (x1*(y[1+(i-1)*WY] + 2*y[1+(i)*WY]) + 3*y[0+(i-1)*WY] - 3*y[0+(i)*WY])/pow(x1, 2);
    c[i*2*WY+3] = (x1*(y[1+(i-1)*WY] + y[1+(i)*WY]) + 2*y[0+(i-1)*WY] - 2*y[0+(i)*WY])/pow(x1, 3);
}
#undef WY
#define WY 3
void poly_coeff3(const double * const restrict x,
			 const double * const restrict y,
			 double * const restrict c, 
			 const int nx){
#pragma omp parallel for
    for (int i=0; i < (nx-1); ++i){
	const double x1 = x[i+1]-x[i];
	const double cse0 = pow(x1, 2);
	const double cse1 = 3*y[2+i*WY];
	const double cse2 = y[1+i*WY] + y[1+(i+1)*WY];
	c[i*2*WY+0] = y[0+i*WY];
	c[i*2*WY+1] = y[1+i*WY];
	c[i*2*WY+2] = (1.0L/2.0L)*y[2+i*WY];
	c[i*2*WY+3] = (1.0L/2.0L)*(cse0*(-cse1 + y[2+(i+1)*WY]) - 4*x1*(2*cse2 + y[1+i*WY]) - 20*y[0+i*WY] + 20*y[0+(i+1)*WY])/pow(x1, 3);
	c[i*2*WY+4] = ((1.0L/2.0L)*pow(x1, 2)*(cse1 - 2*y[2+(i+1)*WY]) + x1*(7*cse2 + y[1+i*WY]) + 15*y[0+i*WY] - 15*y[0+(i+1)*WY])/pow(x1, 4);
	c[i*2*WY+5] = (1.0L/2.0L)*(cse0*(-y[2+i*WY] + y[2+(i+1)*WY]) - 6*cse2*x1 - 12*y[0+i*WY] + 12*y[0+(i+1)*WY])/pow(x1, 5);
    }
    const int i = nx-1;
    const double x1 = x[i]-x[i-1];
    c[i*2*WY+0] = y[0+(i)*WY];
    c[i*2*WY+1] = y[1+(i)*WY];
    c[i*2*WY+2] = (1.0L/2.0L)*y[2+(i)*WY];
    c[i*2*WY+3] = (1.0L/2.0L)*(pow(x1, 2)*(-y[2+(i-1)*WY] + 3*y[2+(i)*WY]) - 4*x1*(2*y[1+(i-1)*WY] + 3*y[1+(i)*WY]) - 20*y[0+(i-1)*WY] + 20*y[0+(i)*WY])/pow(x1, 3);
    c[i*2*WY+4] = ((1.0L/2.0L)*pow(x1, 2)*(-2*y[2+(i-1)*WY] + 3*y[2+(i)*WY]) - x1*(7*y[1+(i-1)*WY] + 8*y[1+(i)*WY]) - 15*y[0+(i-1)*WY] + 15*y[0+(i)*WY])/pow(x1, 4);
    c[i*2*WY+5] = (1.0L/2.0L)*(pow(x1, 2)*(-y[2+(i-1)*WY] + y[2+(i)*WY]) - 6*x1*(y[1+(i-1)*WY] + y[1+(i)*WY]) - 12*y[0+(i-1)*WY] + 12*y[0+(i)*WY])/pow(x1, 5);
}
#undef WY
#undef pow
