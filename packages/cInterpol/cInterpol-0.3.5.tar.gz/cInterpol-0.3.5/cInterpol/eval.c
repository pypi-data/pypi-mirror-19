// DO NOT EDIT THIS FILE! (Generated from template: eval_template.c using Mako python templating engine)
//#include <math.h>
#include "power.c"
//#include <stdio.h>
#include "newton_interval.h"

#define BREAKEVEN 100 // TODO: determine a typical value for this

// we only have integer exponents in pow, use specialized verion:
#define pow(arg1, arg2) power(arg1, arg2)

double poly_scalar_1_0(
    const double x, const double * const restrict c, const int offset)
{
    return c[0+offset] + c[1+offset]*x;
}

void poly_eval_1_0(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_1_0(xout[oi]-x[xi], c, xi*1*2);
    }
}

double poly_scalar_1_1(
    const double x, const double * const restrict c, const int offset)
{
    return c[1+offset];
}

void poly_eval_1_1(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_1_1(xout[oi]-x[xi], c, xi*1*2);
    }
}

double poly_scalar_2_0(
    const double x, const double * const restrict c, const int offset)
{
    return c[0+offset] + c[1+offset]*x + c[2+offset]*pow(x, 2) + c[3+offset]*pow(x, 3);
}

void poly_eval_2_0(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_2_0(xout[oi]-x[xi], c, xi*2*2);
    }
}

double poly_scalar_2_1(
    const double x, const double * const restrict c, const int offset)
{
    return c[1+offset] + 2*c[2+offset]*x + 3*c[3+offset]*pow(x, 2);
}

void poly_eval_2_1(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_2_1(xout[oi]-x[xi], c, xi*2*2);
    }
}

double poly_scalar_2_2(
    const double x, const double * const restrict c, const int offset)
{
    return 2*c[2+offset] + 6*c[3+offset]*x;
}

void poly_eval_2_2(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_2_2(xout[oi]-x[xi], c, xi*2*2);
    }
}

double poly_scalar_2_3(
    const double x, const double * const restrict c, const int offset)
{
    return 6*c[3+offset];
}

void poly_eval_2_3(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_2_3(xout[oi]-x[xi], c, xi*2*2);
    }
}

double poly_scalar_3_0(
    const double x, const double * const restrict c, const int offset)
{
    return c[0+offset] + c[1+offset]*x + c[2+offset]*pow(x, 2) + c[3+offset]*pow(x, 3) + c[4+offset]*pow(x, 4) + c[5+offset]*pow(x, 5);
}

void poly_eval_3_0(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_3_0(xout[oi]-x[xi], c, xi*3*2);
    }
}

double poly_scalar_3_1(
    const double x, const double * const restrict c, const int offset)
{
    return c[1+offset] + 2*c[2+offset]*x + 3*c[3+offset]*pow(x, 2) + 4*c[4+offset]*pow(x, 3) + 5*c[5+offset]*pow(x, 4);
}

void poly_eval_3_1(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_3_1(xout[oi]-x[xi], c, xi*3*2);
    }
}

double poly_scalar_3_2(
    const double x, const double * const restrict c, const int offset)
{
    return 2*c[2+offset] + 6*c[3+offset]*x + 12*c[4+offset]*pow(x, 2) + 20*c[5+offset]*pow(x, 3);
}

void poly_eval_3_2(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_3_2(xout[oi]-x[xi], c, xi*3*2);
    }
}

double poly_scalar_3_3(
    const double x, const double * const restrict c, const int offset)
{
    return 6*c[3+offset] + 24*c[4+offset]*x + 60*c[5+offset]*pow(x, 2);
}

void poly_eval_3_3(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_3_3(xout[oi]-x[xi], c, xi*3*2);
    }
}

double poly_scalar_3_4(
    const double x, const double * const restrict c, const int offset)
{
    return 24*c[4+offset] + 120*c[5+offset]*x;
}

void poly_eval_3_4(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_3_4(xout[oi]-x[xi], c, xi*3*2);
    }
}

double poly_scalar_3_5(
    const double x, const double * const restrict c, const int offset)
{
    return 120*c[5+offset];
}

void poly_eval_3_5(
    const int nx,
    const double * const restrict x,
    const double * const restrict c,
    const int nout,
    const double * const restrict xout, 
    double * const restrict yout
    )
{
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    int xi = nx; // max: nx-1, nx considered "uninitialized"

#pragma omp parallel for firstprivate(xi) schedule(static) if (nout > BREAKEVEN)
    for (int oi=0; oi<nout; ++oi){
	// Set xi
	if (xi == nx){ // xi == nx considered uninitialized!
	    xi = get_interval(x, nx, xout[oi]);
	    if (xi == -1)
		xi = 0;
	}
	else{
	    xi = get_interval_from_guess(x, nx, xout[oi], xi);
	    if (xi == -1)
		xi = 0;
	}

	// Calculate value of yout[oi] at xout[oi]
	// for shifted coefficients.
	yout[oi] = poly_scalar_3_5(xout[oi]-x[xi], c, xi*3*2);
    }
}
#undef pow(arg1, arg2)
