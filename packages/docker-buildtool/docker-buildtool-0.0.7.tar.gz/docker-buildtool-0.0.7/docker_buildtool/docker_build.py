import six
import logging
import os
import platform
import re
import tempfile
import time
import datetime

if six.PY2:
    import glob2 as glob
else:
    import glob

from docker_buildtool import error, utils, versioner

logger = logging.getLogger(__name__)

def expand_include(paths, build_root):
    expanded = []
    for path in paths:
        matches = glob.glob(os.path.join(build_root, path), recursive=True)
        if '*' not in path:
            assert len(matches) > 0, 'No matches found for path'

        expanded += matches

    truncated = []
    for e in expanded:
        assert e.startswith(build_root+'/')
        truncated.append(e[len(build_root)+1:])
    return truncated

class DockerBuild(object):
    def __init__(self, dockerfile, build_root, include, docker_repo, workdir=None, ignore=None, tag=None, default_ignore=None, include_version_file=False, variables=None):
        self.dockerfile = os.path.abspath(dockerfile)
        self.build_root = os.path.abspath(build_root)
        self.workdir = workdir
        self.include = include
        self.docker_repo = docker_repo
        if tag is None:
            tag = 'latest'
        self.tag = tag
        self.ignore = ignore or []
        self.dockerignore = os.path.join(self.build_root, '.dockerignore')
        if variables is None:
            variables = {}
        self.variables = variables
        self.include_version_file = include_version_file

        # TODO: phase this out
        if default_ignore or default_ignore is None:
            self.default_ignore = ['**/.git', '**/*.egg-info', '**/*.o']
        else:
            self.default_ignore = []

    def backup_dockerignore(self, dryrun):
        bak = None
        if os.path.exists(self.dockerignore):
            bak = os.path.join(self.build_root, '.dockerignore.tmp.{}'.format(time.time()))
            utils.rename(dryrun, self.dockerignore, bak)
        return bak

    def restore_dockerignore(self, dryrun, bak):
        if bak is None:
            utils.unlink(dryrun, self.dockerignore)
        else:
            utils.rename(dryrun, bak, self.dockerignore)

    def write_dockerignore(self, dryrun, lines):
        for line in lines:
            assert isinstance(line, str), 'Invalid dockerignore line type {}: {}'.format(type(line), line)

        contents = '# Auto-generated dockerignore by docker_build.py\n' + '\n'.join(lines) + '\n'
        utils.write(dryrun, self.dockerignore, contents)

    def write_dockerfile(self, dryrun):
        with open(self.dockerfile) as f:
            original = f.readlines()

        contents = []
        for line in original:
            transformed = False

            # Expand includes
            match = re.search('^#docker-buildtool:include (.*)$', line)
            if match is not None:
                transformed = True

                include_path = match.group(1)
                logger.info('Including into Dockerfile: path=%s', include_path)
                with open(os.path.join(self.build_root, include_path)) as f:
                    include = f.read()
                line = '''
# starting include from {}
{}
# ending include from {}
'''.format(include_path, include, include_path)

            # Expand variables, right now just supporting a single
            # word until end of line.
            match = re.search('^(.*)#docker-buildtool:variable ([\w-]*)$', line)
            if not transformed and match is not None:
                transformed = True

                prefix = match.group(1)
                variable = match.group(2)
                if variable not in self.variables:
                    raise error.UndefinedVariable('No such variable: {}'.format(variable))
                logger.info('Substituting variable: variable=%s', variable)
                line = "{}{}".format(prefix, self.variables[variable])
            contents.append(line)


        # add versionfile build arg
        if self.include_version_file:
            contents.append('''
ARG versionfile
COPY $versionfile /app/docker-buildtool-version.txt
''')

        if self.workdir is not None:
            contents.append("""

# Ending auto-generated by docker_build.py
WORKDIR {}
""".format(self.workdir))

        tmpfile = utils.named_temporary_file(dryrun, dir=self.build_root)
        utils.write(dryrun, tmpfile.name, '\n'.join(contents))

        return tmpfile

    def write_version_string(self, outfile, timestamp, dryrun=False):
        v = versioner.Versioner(dockerfile=self.dockerfile)
        versions = v.run(no_fetch=dryrun)
        full_version_string = '\n\n'.join([
'''{name}
{version_string}'''.format(name=name, version_string=version_string)
            for (name, version_string) in sorted(versions.items())])
        full_version_string = (str(timestamp) + '\n' + datetime.datetime.fromtimestamp(timestamp).isoformat() +
                                   '\n\n' + full_version_string + '\n')
        if not dryrun:
            with open(outfile, 'w') as f:
                f.write(full_version_string)

    def run(self, dryrun=False):
        include_paths = []
        for entry in self.include:
            path = entry.to_path(build_root=self.build_root)
            include_paths.append(path)

        custom_dockerfile = None
        versionfile = None
        bak = self.backup_dockerignore(dryrun)
        try:
            # Run this before computing ignore, so we don't include it in the container
            custom_dockerfile = self.write_dockerfile(dryrun)

            # Empirically, dockerignore doesn't seem to expand negated
            # ** (or interior *) patterns. We expand these ourselves.
            include_paths = expand_include(include_paths, self.build_root)

            # Ignore everything that's not whitelisted
            ignore = ['*'] + \
                     ['!'+include for include in include_paths] + \
                     self.ignore + \
                     self.default_ignore

            self.write_dockerignore(dryrun, ignore)

            if self.docker_repo is not None:
                image = '{}:{}'.format(self.docker_repo, self.tag)
                tag = ['-t', image]
            else:
                tag = []

            if self.include_version_file:
                timestamp=int(time.time())

                if len(include_paths) > 0:
                    versionfile_dir = include_paths[0] # choose an arbitrary included subdir to store this
                else:
                    raise error.Error('No include_paths were given, so there is nowhere to save a versionfile')

                versionfile = utils.named_temporary_file(dryrun, dir=os.path.join(self.build_root, versionfile_dir))
                logger.info("Including version file. Temporary file at %s", versionfile.name)
                self.write_version_string(outfile=versionfile.name, timestamp=timestamp, dryrun=dryrun)

                versionfile_relpath = os.path.join(versionfile_dir, os.path.basename(versionfile.name))
                utils.execute_command(dryrun, ['docker', 'build', '-f', custom_dockerfile.name,
                    '--build-arg', 'versionfile={}'.format(versionfile_relpath)]
                    + tag + [self.build_root])
            else:
                logger.info("Not including a version file")
                utils.execute_command(dryrun, ['docker', 'build', '-f', custom_dockerfile.name]
                                        + tag + [self.build_root])

        finally:
            if custom_dockerfile:
                custom_dockerfile.close()
            if versionfile:
                versionfile.close()
            self.restore_dockerignore(dryrun, bak)
