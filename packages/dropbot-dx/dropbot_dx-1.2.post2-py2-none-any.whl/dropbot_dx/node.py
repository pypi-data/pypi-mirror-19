
# ############################################################################
# [2017-01-16 14:37:06.196000] THIS FILE IS AUTOGENERATED - DO NOT EDIT!
# ############################################################################
import types
import pandas as pd
import numpy as np
from nadamq.NadaMq import cPacket, PACKET_TYPES
from arduino_rpc.proxy import ProxyBase
try:
    from google.protobuf.message import Message
    _translate = (lambda arg: arg.SerializeToString()
                  if isinstance(arg, Message) else arg)
except ImportError:
    _translate = lambda arg: arg



from base_node_rpc.proxy import ProxyBase, I2cProxyMixin, SerialProxyMixin



class Proxy(ProxyBase):


    _CMD_BASE_NODE_SOFTWARE_VERSION = 0x00
    _CMD_PACKAGE_NAME = 0x01
    _CMD_DISPLAY_NAME = 0x02
    _CMD_MANUFACTURER = 0x03
    _CMD_SOFTWARE_VERSION = 0x04
    _CMD_URL = 0x05
    _CMD_MICROSECONDS = 0x06
    _CMD_MILLISECONDS = 0x07
    _CMD_DELAY_US = 0x08
    _CMD_DELAY_MS = 0x09
    _CMD_RAM_FREE = 0x0a
    _CMD_PIN_MODE = 0x0b
    _CMD_DIGITAL_READ = 0x0c
    _CMD_DIGITAL_WRITE = 0x0d
    _CMD_ANALOG_READ = 0x0e
    _CMD_ANALOG_WRITE = 0x0f
    _CMD_ARRAY_LENGTH = 0x10
    _CMD_ECHO_ARRAY = 0x11
    _CMD_STR_ECHO = 0x12
    _CMD_MAX_SERIAL_PAYLOAD_SIZE = 0xff
    _CMD_UPDATE_EEPROM_BLOCK = 0x1fe
    _CMD_READ_EEPROM_BLOCK = 0x1ff
    _CMD_EEPROM_E2END = 0x200
    _CMD_SET_CLOCK = 0x2fd
    _CMD_SET_I2C_ADDRESS = 0x2fe
    _CMD_I2C_ADDRESS = 0x2ff
    _CMD_I2C_BUFFER_SIZE = 0x300
    _CMD_I2C_SCAN = 0x301
    _CMD_I2C_AVAILABLE = 0x302
    _CMD_I2C_READ_BYTE = 0x303
    _CMD_I2C_REQUEST_FROM = 0x304
    _CMD_I2C_READ = 0x305
    _CMD_I2C_WRITE = 0x306
    _CMD_I2C_ENABLE_BROADCAST = 0x307
    _CMD_I2C_DISABLE_BROADCAST = 0x308
    _CMD_MAX_I2C_PAYLOAD_SIZE = 0x3fc
    _CMD_I2C_REQUEST = 0x3fd
    _CMD_I2C_PACKET_RESET = 0x3fe
    _CMD_LOAD_CONFIG = 0x4fb
    _CMD_SAVE_CONFIG = 0x4fc
    _CMD_RESET_CONFIG = 0x4fd
    _CMD_SERIALIZE_CONFIG = 0x4fe
    _CMD_UPDATE_CONFIG = 0x4ff
    _CMD_ON_CONFIG_I2C_ADDRESS_CHANGED = 0x500
    _CMD_RESET_STATE = 0x5fa
    _CMD_SERIALIZE_STATE = 0x5fb
    _CMD_UPDATE_STATE = 0x5fc
    _CMD_TIMER_CALLBACK = 0x6f9
    _CMD_GET_BUFFER = 0x6fa
    _CMD_BEGIN = 0x6fb
    _CMD_SERVO_READ = 0x6fc
    _CMD_SERVO_WRITE = 0x6fd
    _CMD_SERVO_WRITE_MICROSECONDS = 0x6fe
    _CMD_SERVO_ATTACHED = 0x6ff
    _CMD_NUMBER_OF_CHANNELS = 0x700
    _CMD_SET_NUMBER_OF_CHANNELS = 0x701
    _CMD_HARDWARE_VERSION = 0x702
    _CMD__UUID = 0x703
    _CMD_STATE_OF_CHANNELS = 0x704
    _CMD_SET_ID = 0x705
    _CMD_SET_STATE_OF_CHANNELS = 0x706
    _CMD_ON_STATE_FREQUENCY_CHANGED = 0x707
    _CMD_MIN_WAVEFORM_VOLTAGE = 0x708
    _CMD__SET_VOLTAGE = 0x709
    _CMD_ON_STATE_VOLTAGE_CHANGED = 0x70a
    _CMD_ON_STATE_HV_OUTPUT_ENABLED_CHANGED = 0x70b
    _CMD_ON_STATE_HV_OUTPUT_SELECTED_CHANGED = 0x70c
    _CMD_ON_STATE_MAGNET_ENGAGED_CHANGED = 0x70d
    _CMD_ON_CONFIG_LIGHT_INTENSITY_CHANGED = 0x70e
    _CMD_ON_STATE_LIGHT_ENABLED_CHANGED = 0x70f
    _CMD_MAGNET_ENGAGED = 0x710
    _CMD__INITIALIZE_SWITCHING_BOARDS = 0x711
    _CMD__MAGNET_ENGAGE = 0x712
    _CMD__MAGNET_DISENGAGE = 0x713
    _CMD_TEST = 0x714
    _CMD_DMA_TCD = 0x715
    _CMD_DMA_START = 0x716
    _CMD_DMA_STOP = 0x717
    _CMD_DMA_READ = 0x718
    _CMD_DMA_FULL = 0x719
    _CMD_DMA_EMPTY = 0x71a
    _CMD_ADC_BUFFER = 0x71b
    _CMD_SETREFERENCE = 0x71c
    _CMD_ON_TICK = 0x71d
    _CMD_V__SYST_CVR = 0x71e
    _CMD_V__SCB_ICSR = 0x71f
    _CMD_D__F_CPU = 0x720
    _CMD_D__F_BUS = 0x721
    _CMD_ON_ADC_DONE = 0x722
    _CMD_ADC_TIMESTAMP_US = 0x723
    _CMD_COMPUTE_TIMESTAMP_US = 0x724
    _CMD_ADC_PERIOD_US = 0x725
    _CMD_SETRESOLUTION = 0x726
    _CMD_GETRESOLUTION = 0x727
    _CMD_GETMAXVALUE = 0x728
    _CMD_SETCONVERSIONSPEED = 0x729
    _CMD_SETSAMPLINGSPEED = 0x72a
    _CMD_BENCHMARK_FLOPS = 0x72b
    _CMD_BENCHMARK_IOPS = 0x72c
    _CMD_SETAVERAGING = 0x72d
    _CMD_ENABLEINTERRUPTS = 0x72e
    _CMD_DISABLEINTERRUPTS = 0x72f
    _CMD_ENABLEDMA = 0x730
    _CMD_DISABLEDMA = 0x731
    _CMD_ENABLECOMPARE = 0x732
    _CMD_ENABLECOMPARERANGE = 0x733
    _CMD_DISABLECOMPARE = 0x734
    _CMD_ENABLEPGA = 0x735
    _CMD_GETPGA = 0x736
    _CMD_DISABLEPGA = 0x737
    _CMD_ISCONVERTING = 0x738
    _CMD_ISCOMPLETE = 0x739
    _CMD_ISDIFFERENTIAL = 0x73a
    _CMD_ISCONTINUOUS = 0x73b
    _CMD_ANALOGREAD = 0x73c
    _CMD_ANALOGREADDIFFERENTIAL = 0x73d
    _CMD_STARTSINGLEREAD = 0x73e
    _CMD_STARTSINGLEDIFFERENTIAL = 0x73f
    _CMD_READSINGLE = 0x740
    _CMD_STARTCONTINUOUS = 0x741
    _CMD_STARTCONTINUOUSDIFFERENTIAL = 0x742
    _CMD_ANALOGREADCONTINUOUS = 0x743
    _CMD_STOPCONTINUOUS = 0x744
    _CMD_ANALOGSYNCHRONIZEDREAD = 0x745
    _CMD_ANALOG_INPUT_TO_DIGITAL_PIN = 0x746
    _CMD_DIGITAL_PIN_HAS_PWM = 0x747
    _CMD_DIGITAL_PIN_TO_INTERRUPT = 0x748
    _CMD_READ_ADC_REGISTERS = 0x749
    _CMD_UPDATE_ADC_REGISTERS = 0x74a
    _CMD_READ_PIT_REGISTERS = 0x74b
    _CMD_UPDATE_PIT_REGISTERS = 0x74c
    _CMD_READ_PIT_TIMER_CONFIG = 0x74d
    _CMD_UPDATE_PIT_TIMER_CONFIG = 0x74e
    _CMD_DMA_CHANNEL_COUNT = 0x74f
    _CMD_READ_DMA_TCD = 0x750
    _CMD_RESET_DMA_TCD = 0x751
    _CMD_UPDATE_DMA_TCD = 0x752
    _CMD_READ_DMA_PRIORITY = 0x753
    _CMD_READ_DMA_REGISTERS = 0x754
    _CMD_UPDATE_DMA_REGISTERS = 0x755
    _CMD_READ_DMA_MUX_CHCFG = 0x756
    _CMD_UPDATE_DMA_MUX_CHCFG = 0x757
    _CMD_CLEAR_DMA_ERRORS = 0x758
    _CMD_READ_SIM_SCGC6 = 0x759
    _CMD_READ_SIM_SCGC7 = 0x75a
    _CMD_UPDATE_SIM_SCGC6 = 0x75b
    _CMD_UPDATE_SIM_SCGC7 = 0x75c
    _CMD_FREE_ALL = 0x75d
    _CMD_MEM_ALLOC = 0x75e
    _CMD_MEM_FREE = 0x75f
    _CMD_MEM_ALIGNED_ALLOC = 0x760
    _CMD_MEM_ALIGNED_FREE = 0x761
    _CMD_MEM_ALIGNED_ALLOC_AND_SET = 0x762
    _CMD_MEM_CPY_HOST_TO_DEVICE = 0x763
    _CMD_MEM_CPY_DEVICE_TO_HOST = 0x764
    _CMD_MEM_FILL_UINT8 = 0x765
    _CMD_MEM_FILL_UINT16 = 0x766
    _CMD_MEM_FILL_UINT32 = 0x767
    _CMD_MEM_FILL_FLOAT = 0x768
    _CMD_LOOP = 0x769
    _CMD_LAST_DMA_CHANNEL_DONE = 0x76a
    _CMD_ATTACH_DMA_INTERRUPT = 0x76b
    _CMD_DETACH_DMA_INTERRUPT = 0x76c
    MAX_COMMAND_CODE = 1900


    def base_node_software_version(self):
        command = np.dtype('uint16').type(self._CMD_BASE_NODE_SOFTWARE_VERSION)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def package_name(self):
        command = np.dtype('uint16').type(self._CMD_PACKAGE_NAME)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def display_name(self):
        command = np.dtype('uint16').type(self._CMD_DISPLAY_NAME)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def manufacturer(self):
        command = np.dtype('uint16').type(self._CMD_MANUFACTURER)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def software_version(self):
        command = np.dtype('uint16').type(self._CMD_SOFTWARE_VERSION)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def url(self):
        command = np.dtype('uint16').type(self._CMD_URL)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def microseconds(self):
        command = np.dtype('uint16').type(self._CMD_MICROSECONDS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def milliseconds(self):
        command = np.dtype('uint16').type(self._CMD_MILLISECONDS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def delay_us(self, us):
        command = np.dtype('uint16').type(self._CMD_DELAY_US)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(us, )],
                               dtype=[('us', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def delay_ms(self, ms):
        command = np.dtype('uint16').type(self._CMD_DELAY_MS)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(ms, )],
                               dtype=[('ms', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def ram_free(self):
        command = np.dtype('uint16').type(self._CMD_RAM_FREE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def pin_mode(self, pin, mode):
        command = np.dtype('uint16').type(self._CMD_PIN_MODE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, mode, )],
                               dtype=[('pin', 'uint8'), ('mode', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def digital_read(self, pin):
        command = np.dtype('uint16').type(self._CMD_DIGITAL_READ)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def digital_write(self, pin, value):
        command = np.dtype('uint16').type(self._CMD_DIGITAL_WRITE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, value, )],
                               dtype=[('pin', 'uint8'), ('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def analog_read(self, pin):
        command = np.dtype('uint16').type(self._CMD_ANALOG_READ)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def analog_write(self, pin, value):
        command = np.dtype('uint16').type(self._CMD_ANALOG_WRITE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, value, )],
                               dtype=[('pin', 'uint8'), ('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def array_length(self, array):
        command = np.dtype('uint16').type(self._CMD_ARRAY_LENGTH)
        ARG_STRUCT_SIZE = 8

        array = _translate(array)
        if isinstance(array, str):
            array = map(ord, array)
        # Argument is an array, so cast to appropriate array type.
        array = np.ascontiguousarray(array, dtype='uint8')
        array_info = pd.DataFrame([array.shape[0], ],
                                  index=['array', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([array.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['array'], ARG_STRUCT_SIZE + array_info.start['array'], )],
                               dtype=[('array_length', 'uint32'), ('array_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def echo_array(self, array):
        command = np.dtype('uint16').type(self._CMD_ECHO_ARRAY)
        ARG_STRUCT_SIZE = 8

        array = _translate(array)
        if isinstance(array, str):
            array = map(ord, array)
        # Argument is an array, so cast to appropriate array type.
        array = np.ascontiguousarray(array, dtype='uint32')
        array_info = pd.DataFrame([array.shape[0], ],
                                  index=['array', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([array.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['array'], ARG_STRUCT_SIZE + array_info.start['array'], )],
                               dtype=[('array_length', 'uint32'), ('array_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is an array, so return entire array.
        return result


    def str_echo(self, msg):
        command = np.dtype('uint16').type(self._CMD_STR_ECHO)
        ARG_STRUCT_SIZE = 8

        msg = _translate(msg)
        if isinstance(msg, str):
            msg = map(ord, msg)
        # Argument is an array, so cast to appropriate array type.
        msg = np.ascontiguousarray(msg, dtype='uint8')
        array_info = pd.DataFrame([msg.shape[0], ],
                                  index=['msg', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([msg.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['msg'], ARG_STRUCT_SIZE + array_info.start['msg'], )],
                               dtype=[('msg_length', 'uint32'), ('msg_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def max_serial_payload_size(self):
        command = np.dtype('uint16').type(self._CMD_MAX_SERIAL_PAYLOAD_SIZE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def update_eeprom_block(self, address, data):
        command = np.dtype('uint16').type(self._CMD_UPDATE_EEPROM_BLOCK)
        ARG_STRUCT_SIZE = 12

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint32'), ('data_length', 'uint32'), ('data_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def read_eeprom_block(self, address, n):
        command = np.dtype('uint16').type(self._CMD_READ_EEPROM_BLOCK)
        ARG_STRUCT_SIZE = 6
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, n, )],
                               dtype=[('address', 'uint32'), ('n', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def eeprom_e2end(self):
        command = np.dtype('uint16').type(self._CMD_EEPROM_E2END)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def set_clock(self, frequency):
        command = np.dtype('uint16').type(self._CMD_SET_CLOCK)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(frequency, )],
                               dtype=[('frequency', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def set_i2c_address(self, address):
        command = np.dtype('uint16').type(self._CMD_SET_I2C_ADDRESS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, )],
                               dtype=[('address', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def i2c_address(self):
        command = np.dtype('uint16').type(self._CMD_I2C_ADDRESS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_buffer_size(self):
        command = np.dtype('uint16').type(self._CMD_I2C_BUFFER_SIZE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_scan(self):
        command = np.dtype('uint16').type(self._CMD_I2C_SCAN)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def i2c_available(self):
        command = np.dtype('uint16').type(self._CMD_I2C_AVAILABLE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_read_byte(self):
        command = np.dtype('uint16').type(self._CMD_I2C_READ_BYTE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_request_from(self, address, n_bytes_to_read):
        command = np.dtype('uint16').type(self._CMD_I2C_REQUEST_FROM)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, n_bytes_to_read, )],
                               dtype=[('address', 'uint8'), ('n_bytes_to_read', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_read(self, address, n_bytes_to_read):
        command = np.dtype('uint16').type(self._CMD_I2C_READ)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, n_bytes_to_read, )],
                               dtype=[('address', 'uint8'), ('n_bytes_to_read', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def i2c_write(self, address, data):
        command = np.dtype('uint16').type(self._CMD_I2C_WRITE)
        ARG_STRUCT_SIZE = 9

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint8'), ('data_length', 'uint32'), ('data_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def i2c_enable_broadcast(self):
        command = np.dtype('uint16').type(self._CMD_I2C_ENABLE_BROADCAST)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def i2c_disable_broadcast(self):
        command = np.dtype('uint16').type(self._CMD_I2C_DISABLE_BROADCAST)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def max_i2c_payload_size(self):
        command = np.dtype('uint16').type(self._CMD_MAX_I2C_PAYLOAD_SIZE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_request(self, address, data):
        command = np.dtype('uint16').type(self._CMD_I2C_REQUEST)
        ARG_STRUCT_SIZE = 9

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint8'), ('data_length', 'uint32'), ('data_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def i2c_packet_reset(self):
        command = np.dtype('uint16').type(self._CMD_I2C_PACKET_RESET)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def load_config(self):
        command = np.dtype('uint16').type(self._CMD_LOAD_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def save_config(self):
        command = np.dtype('uint16').type(self._CMD_SAVE_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def reset_config(self):
        command = np.dtype('uint16').type(self._CMD_RESET_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def serialize_config(self):
        command = np.dtype('uint16').type(self._CMD_SERIALIZE_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_config(self, serialized):
        command = np.dtype('uint16').type(self._CMD_UPDATE_CONFIG)
        ARG_STRUCT_SIZE = 8

        serialized = _translate(serialized)
        if isinstance(serialized, str):
            serialized = map(ord, serialized)
        # Argument is an array, so cast to appropriate array type.
        serialized = np.ascontiguousarray(serialized, dtype='uint8')
        array_info = pd.DataFrame([serialized.shape[0], ],
                                  index=['serialized', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized'], ARG_STRUCT_SIZE + array_info.start['serialized'], )],
                               dtype=[('serialized_length', 'uint32'), ('serialized_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_config_i2c_address_changed(self, new_value):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_I2C_ADDRESS_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(new_value, )],
                               dtype=[('new_value', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def reset_state(self):
        command = np.dtype('uint16').type(self._CMD_RESET_STATE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def serialize_state(self):
        command = np.dtype('uint16').type(self._CMD_SERIALIZE_STATE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_state(self, serialized):
        command = np.dtype('uint16').type(self._CMD_UPDATE_STATE)
        ARG_STRUCT_SIZE = 8

        serialized = _translate(serialized)
        if isinstance(serialized, str):
            serialized = map(ord, serialized)
        # Argument is an array, so cast to appropriate array type.
        serialized = np.ascontiguousarray(serialized, dtype='uint8')
        array_info = pd.DataFrame([serialized.shape[0], ],
                                  index=['serialized', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized'], ARG_STRUCT_SIZE + array_info.start['serialized'], )],
                               dtype=[('serialized_length', 'uint32'), ('serialized_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def timer_callback(self):
        command = np.dtype('uint16').type(self._CMD_TIMER_CALLBACK)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def get_buffer(self):
        command = np.dtype('uint16').type(self._CMD_GET_BUFFER)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def begin(self):
        command = np.dtype('uint16').type(self._CMD_BEGIN)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def servo_read(self):
        command = np.dtype('uint16').type(self._CMD_SERVO_READ)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def servo_write(self, angle):
        command = np.dtype('uint16').type(self._CMD_SERVO_WRITE)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(angle, )],
                               dtype=[('angle', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def servo_write_microseconds(self, us):
        command = np.dtype('uint16').type(self._CMD_SERVO_WRITE_MICROSECONDS)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(us, )],
                               dtype=[('us', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def servo_attached(self):
        command = np.dtype('uint16').type(self._CMD_SERVO_ATTACHED)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def number_of_channels(self):
        command = np.dtype('uint16').type(self._CMD_NUMBER_OF_CHANNELS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def set_number_of_channels(self, number_of_channels):
        command = np.dtype('uint16').type(self._CMD_SET_NUMBER_OF_CHANNELS)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(number_of_channels, )],
                               dtype=[('number_of_channels', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def hardware_version(self):
        command = np.dtype('uint16').type(self._CMD_HARDWARE_VERSION)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def _uuid(self):
        command = np.dtype('uint16').type(self._CMD__UUID)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def state_of_channels(self):
        command = np.dtype('uint16').type(self._CMD_STATE_OF_CHANNELS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def set_id(self, id):
        command = np.dtype('uint16').type(self._CMD_SET_ID)
        ARG_STRUCT_SIZE = 8

        id = _translate(id)
        if isinstance(id, str):
            id = map(ord, id)
        # Argument is an array, so cast to appropriate array type.
        id = np.ascontiguousarray(id, dtype='uint8')
        array_info = pd.DataFrame([id.shape[0], ],
                                  index=['id', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([id.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['id'], ARG_STRUCT_SIZE + array_info.start['id'], )],
                               dtype=[('id_length', 'uint32'), ('id_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def set_state_of_channels(self, channel_states):
        command = np.dtype('uint16').type(self._CMD_SET_STATE_OF_CHANNELS)
        ARG_STRUCT_SIZE = 8

        channel_states = _translate(channel_states)
        if isinstance(channel_states, str):
            channel_states = map(ord, channel_states)
        # Argument is an array, so cast to appropriate array type.
        channel_states = np.ascontiguousarray(channel_states, dtype='uint8')
        array_info = pd.DataFrame([channel_states.shape[0], ],
                                  index=['channel_states', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([channel_states.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['channel_states'], ARG_STRUCT_SIZE + array_info.start['channel_states'], )],
                               dtype=[('channel_states_length', 'uint32'), ('channel_states_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_frequency_changed(self, frequency):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_FREQUENCY_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(frequency, )],
                               dtype=[('frequency', 'float32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def min_waveform_voltage(self):
        command = np.dtype('uint16').type(self._CMD_MIN_WAVEFORM_VOLTAGE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='float32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def _set_voltage(self, voltage):
        command = np.dtype('uint16').type(self._CMD__SET_VOLTAGE)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(voltage, )],
                               dtype=[('voltage', 'float32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_voltage_changed(self, voltage):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_VOLTAGE_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(voltage, )],
                               dtype=[('voltage', 'float32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_hv_output_enabled_changed(self, value):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_HV_OUTPUT_ENABLED_CHANGED)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(value, )],
                               dtype=[('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_hv_output_selected_changed(self, value):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_HV_OUTPUT_SELECTED_CHANGED)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(value, )],
                               dtype=[('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_magnet_engaged_changed(self, value):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_MAGNET_ENGAGED_CHANGED)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(value, )],
                               dtype=[('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_config_light_intensity_changed(self, value):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_LIGHT_INTENSITY_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(value, )],
                               dtype=[('value', 'float32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_light_enabled_changed(self, value):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_LIGHT_ENABLED_CHANGED)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(value, )],
                               dtype=[('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def magnet_engaged(self):
        command = np.dtype('uint16').type(self._CMD_MAGNET_ENGAGED)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def _initialize_switching_boards(self):
        command = np.dtype('uint16').type(self._CMD__INITIALIZE_SWITCHING_BOARDS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def _magnet_engage(self):
        command = np.dtype('uint16').type(self._CMD__MAGNET_ENGAGE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def _magnet_disengage(self):
        command = np.dtype('uint16').type(self._CMD__MAGNET_DISENGAGE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def test(self, a):
        command = np.dtype('uint16').type(self._CMD_TEST)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(a, )],
                               dtype=[('a', 'float32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='float32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def dma_tcd(self):
        command = np.dtype('uint16').type(self._CMD_DMA_TCD)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def dma_start(self, buffer_size):
        command = np.dtype('uint16').type(self._CMD_DMA_START)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(buffer_size, )],
                               dtype=[('buffer_size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def dma_stop(self):
        command = np.dtype('uint16').type(self._CMD_DMA_STOP)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def dma_read(self):
        command = np.dtype('uint16').type(self._CMD_DMA_READ)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def dma_full(self):
        command = np.dtype('uint16').type(self._CMD_DMA_FULL)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def dma_empty(self):
        command = np.dtype('uint16').type(self._CMD_DMA_EMPTY)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def adc_buffer(self):
        command = np.dtype('uint16').type(self._CMD_ADC_BUFFER)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is an array, so return entire array.
        return result


    def setReference(self, type, adc_num):
        command = np.dtype('uint16').type(self._CMD_SETREFERENCE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(type, adc_num, )],
                               dtype=[('type', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def on_tick(self):
        command = np.dtype('uint16').type(self._CMD_ON_TICK)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def V__SYST_CVR(self):
        command = np.dtype('uint16').type(self._CMD_V__SYST_CVR)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def V__SCB_ICSR(self):
        command = np.dtype('uint16').type(self._CMD_V__SCB_ICSR)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def D__F_CPU(self):
        command = np.dtype('uint16').type(self._CMD_D__F_CPU)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def D__F_BUS(self):
        command = np.dtype('uint16').type(self._CMD_D__F_BUS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_adc_done(self):
        command = np.dtype('uint16').type(self._CMD_ON_ADC_DONE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def adc_timestamp_us(self):
        command = np.dtype('uint16').type(self._CMD_ADC_TIMESTAMP_US)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='float32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def compute_timestamp_us(self, _SYST_CVR, _millis):
        command = np.dtype('uint16').type(self._CMD_COMPUTE_TIMESTAMP_US)
        ARG_STRUCT_SIZE = 8
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(_SYST_CVR, _millis, )],
                               dtype=[('_SYST_CVR', 'uint32'), ('_millis', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='float32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def adc_period_us(self):
        command = np.dtype('uint16').type(self._CMD_ADC_PERIOD_US)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='float32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def setResolution(self, bits, adc_num):
        command = np.dtype('uint16').type(self._CMD_SETRESOLUTION)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(bits, adc_num, )],
                               dtype=[('bits', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def getResolution(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_GETRESOLUTION)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def getMaxValue(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_GETMAXVALUE)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def setConversionSpeed(self, speed, adc_num):
        command = np.dtype('uint16').type(self._CMD_SETCONVERSIONSPEED)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(speed, adc_num, )],
                               dtype=[('speed', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def setSamplingSpeed(self, speed, adc_num):
        command = np.dtype('uint16').type(self._CMD_SETSAMPLINGSPEED)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(speed, adc_num, )],
                               dtype=[('speed', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def benchmark_flops(self, N):
        command = np.dtype('uint16').type(self._CMD_BENCHMARK_FLOPS)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(N, )],
                               dtype=[('N', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def benchmark_iops(self, N):
        command = np.dtype('uint16').type(self._CMD_BENCHMARK_IOPS)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(N, )],
                               dtype=[('N', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def setAveraging(self, num, adc_num):
        command = np.dtype('uint16').type(self._CMD_SETAVERAGING)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(num, adc_num, )],
                               dtype=[('num', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def enableInterrupts(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ENABLEINTERRUPTS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def disableInterrupts(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_DISABLEINTERRUPTS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def enableDMA(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ENABLEDMA)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def disableDMA(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_DISABLEDMA)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def enableCompare(self, compValue, greaterThan, adc_num):
        command = np.dtype('uint16').type(self._CMD_ENABLECOMPARE)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(compValue, greaterThan, adc_num, )],
                               dtype=[('compValue', 'int16'), ('greaterThan', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def enableCompareRange(self, lowerLimit, upperLimit, insideRange, inclusive, adc_num):
        command = np.dtype('uint16').type(self._CMD_ENABLECOMPARERANGE)
        ARG_STRUCT_SIZE = 7
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(lowerLimit, upperLimit, insideRange, inclusive, adc_num, )],
                               dtype=[('lowerLimit', 'int16'), ('upperLimit', 'int16'), ('insideRange', 'uint8'), ('inclusive', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def disableCompare(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_DISABLECOMPARE)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def enablePGA(self, gain, adc_num):
        command = np.dtype('uint16').type(self._CMD_ENABLEPGA)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(gain, adc_num, )],
                               dtype=[('gain', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def getPGA(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_GETPGA)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def disablePGA(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_DISABLEPGA)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def isConverting(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ISCONVERTING)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def isComplete(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ISCOMPLETE)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def isDifferential(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ISDIFFERENTIAL)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def isContinuous(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ISCONTINUOUS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def analogRead(self, pin, adc_num):
        command = np.dtype('uint16').type(self._CMD_ANALOGREAD)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, adc_num, )],
                               dtype=[('pin', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def analogReadDifferential(self, pinP, pinN, adc_num):
        command = np.dtype('uint16').type(self._CMD_ANALOGREADDIFFERENTIAL)
        ARG_STRUCT_SIZE = 3
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pinP, pinN, adc_num, )],
                               dtype=[('pinP', 'uint8'), ('pinN', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def startSingleRead(self, pin, adc_num):
        command = np.dtype('uint16').type(self._CMD_STARTSINGLEREAD)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, adc_num, )],
                               dtype=[('pin', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def startSingleDifferential(self, pinP, pinN, adc_num):
        command = np.dtype('uint16').type(self._CMD_STARTSINGLEDIFFERENTIAL)
        ARG_STRUCT_SIZE = 3
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pinP, pinN, adc_num, )],
                               dtype=[('pinP', 'uint8'), ('pinN', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def readSingle(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_READSINGLE)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def startContinuous(self, pin, adc_num):
        command = np.dtype('uint16').type(self._CMD_STARTCONTINUOUS)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, adc_num, )],
                               dtype=[('pin', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def startContinuousDifferential(self, pinP, pinN, adc_num):
        command = np.dtype('uint16').type(self._CMD_STARTCONTINUOUSDIFFERENTIAL)
        ARG_STRUCT_SIZE = 3
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pinP, pinN, adc_num, )],
                               dtype=[('pinP', 'uint8'), ('pinN', 'uint8'), ('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def analogReadContinuous(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_ANALOGREADCONTINUOUS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def stopContinuous(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_STOPCONTINUOUS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'int8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def analogSynchronizedRead(self, pin0, pin1):
        command = np.dtype('uint16').type(self._CMD_ANALOGSYNCHRONIZEDREAD)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin0, pin1, )],
                               dtype=[('pin0', 'uint8'), ('pin1', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is an array, so return entire array.
        return result


    def analog_input_to_digital_pin(self, pin):
        command = np.dtype('uint16').type(self._CMD_ANALOG_INPUT_TO_DIGITAL_PIN)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def digital_pin_has_pwm(self, pin):
        command = np.dtype('uint16').type(self._CMD_DIGITAL_PIN_HAS_PWM)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def digital_pin_to_interrupt(self, pin):
        command = np.dtype('uint16').type(self._CMD_DIGITAL_PIN_TO_INTERRUPT)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def read_adc_registers(self, adc_num):
        command = np.dtype('uint16').type(self._CMD_READ_ADC_REGISTERS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, )],
                               dtype=[('adc_num', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_adc_registers(self, adc_num, serialized_adc_msg):
        command = np.dtype('uint16').type(self._CMD_UPDATE_ADC_REGISTERS)
        ARG_STRUCT_SIZE = 9

        serialized_adc_msg = _translate(serialized_adc_msg)
        if isinstance(serialized_adc_msg, str):
            serialized_adc_msg = map(ord, serialized_adc_msg)
        # Argument is an array, so cast to appropriate array type.
        serialized_adc_msg = np.ascontiguousarray(serialized_adc_msg, dtype='uint8')
        array_info = pd.DataFrame([serialized_adc_msg.shape[0], ],
                                  index=['serialized_adc_msg', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_adc_msg.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(adc_num, array_info.length['serialized_adc_msg'], ARG_STRUCT_SIZE + array_info.start['serialized_adc_msg'], )],
                               dtype=[('adc_num', 'uint8'), ('serialized_adc_msg_length', 'uint32'), ('serialized_adc_msg_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def read_pit_registers(self):
        command = np.dtype('uint16').type(self._CMD_READ_PIT_REGISTERS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_pit_registers(self, serialized_pit_msg):
        command = np.dtype('uint16').type(self._CMD_UPDATE_PIT_REGISTERS)
        ARG_STRUCT_SIZE = 8

        serialized_pit_msg = _translate(serialized_pit_msg)
        if isinstance(serialized_pit_msg, str):
            serialized_pit_msg = map(ord, serialized_pit_msg)
        # Argument is an array, so cast to appropriate array type.
        serialized_pit_msg = np.ascontiguousarray(serialized_pit_msg, dtype='uint8')
        array_info = pd.DataFrame([serialized_pit_msg.shape[0], ],
                                  index=['serialized_pit_msg', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_pit_msg.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized_pit_msg'], ARG_STRUCT_SIZE + array_info.start['serialized_pit_msg'], )],
                               dtype=[('serialized_pit_msg_length', 'uint32'), ('serialized_pit_msg_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def read_pit_timer_config(self, timer_index):
        command = np.dtype('uint16').type(self._CMD_READ_PIT_TIMER_CONFIG)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(timer_index, )],
                               dtype=[('timer_index', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_pit_timer_config(self, index, serialized_config):
        command = np.dtype('uint16').type(self._CMD_UPDATE_PIT_TIMER_CONFIG)
        ARG_STRUCT_SIZE = 12

        serialized_config = _translate(serialized_config)
        if isinstance(serialized_config, str):
            serialized_config = map(ord, serialized_config)
        # Argument is an array, so cast to appropriate array type.
        serialized_config = np.ascontiguousarray(serialized_config, dtype='uint8')
        array_info = pd.DataFrame([serialized_config.shape[0], ],
                                  index=['serialized_config', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_config.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(index, array_info.length['serialized_config'], ARG_STRUCT_SIZE + array_info.start['serialized_config'], )],
                               dtype=[('index', 'uint32'), ('serialized_config_length', 'uint32'), ('serialized_config_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def dma_channel_count(self):
        command = np.dtype('uint16').type(self._CMD_DMA_CHANNEL_COUNT)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def read_dma_TCD(self, channel_num):
        command = np.dtype('uint16').type(self._CMD_READ_DMA_TCD)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(channel_num, )],
                               dtype=[('channel_num', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def reset_dma_TCD(self, channel_num):
        command = np.dtype('uint16').type(self._CMD_RESET_DMA_TCD)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(channel_num, )],
                               dtype=[('channel_num', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def update_dma_TCD(self, channel_num, serialized_tcd):
        command = np.dtype('uint16').type(self._CMD_UPDATE_DMA_TCD)
        ARG_STRUCT_SIZE = 9

        serialized_tcd = _translate(serialized_tcd)
        if isinstance(serialized_tcd, str):
            serialized_tcd = map(ord, serialized_tcd)
        # Argument is an array, so cast to appropriate array type.
        serialized_tcd = np.ascontiguousarray(serialized_tcd, dtype='uint8')
        array_info = pd.DataFrame([serialized_tcd.shape[0], ],
                                  index=['serialized_tcd', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_tcd.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(channel_num, array_info.length['serialized_tcd'], ARG_STRUCT_SIZE + array_info.start['serialized_tcd'], )],
                               dtype=[('channel_num', 'uint8'), ('serialized_tcd_length', 'uint32'), ('serialized_tcd_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def read_dma_priority(self, channel_num):
        command = np.dtype('uint16').type(self._CMD_READ_DMA_PRIORITY)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(channel_num, )],
                               dtype=[('channel_num', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def read_dma_registers(self):
        command = np.dtype('uint16').type(self._CMD_READ_DMA_REGISTERS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_dma_registers(self, serialized_dma_msg):
        command = np.dtype('uint16').type(self._CMD_UPDATE_DMA_REGISTERS)
        ARG_STRUCT_SIZE = 8

        serialized_dma_msg = _translate(serialized_dma_msg)
        if isinstance(serialized_dma_msg, str):
            serialized_dma_msg = map(ord, serialized_dma_msg)
        # Argument is an array, so cast to appropriate array type.
        serialized_dma_msg = np.ascontiguousarray(serialized_dma_msg, dtype='uint8')
        array_info = pd.DataFrame([serialized_dma_msg.shape[0], ],
                                  index=['serialized_dma_msg', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_dma_msg.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized_dma_msg'], ARG_STRUCT_SIZE + array_info.start['serialized_dma_msg'], )],
                               dtype=[('serialized_dma_msg_length', 'uint32'), ('serialized_dma_msg_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def read_dma_mux_chcfg(self, channel_num):
        command = np.dtype('uint16').type(self._CMD_READ_DMA_MUX_CHCFG)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(channel_num, )],
                               dtype=[('channel_num', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_dma_mux_chcfg(self, channel_num, serialized_mux):
        command = np.dtype('uint16').type(self._CMD_UPDATE_DMA_MUX_CHCFG)
        ARG_STRUCT_SIZE = 9

        serialized_mux = _translate(serialized_mux)
        if isinstance(serialized_mux, str):
            serialized_mux = map(ord, serialized_mux)
        # Argument is an array, so cast to appropriate array type.
        serialized_mux = np.ascontiguousarray(serialized_mux, dtype='uint8')
        array_info = pd.DataFrame([serialized_mux.shape[0], ],
                                  index=['serialized_mux', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_mux.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(channel_num, array_info.length['serialized_mux'], ARG_STRUCT_SIZE + array_info.start['serialized_mux'], )],
                               dtype=[('channel_num', 'uint8'), ('serialized_mux_length', 'uint32'), ('serialized_mux_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def clear_dma_errors(self):
        command = np.dtype('uint16').type(self._CMD_CLEAR_DMA_ERRORS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def read_sim_SCGC6(self):
        command = np.dtype('uint16').type(self._CMD_READ_SIM_SCGC6)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def read_sim_SCGC7(self):
        command = np.dtype('uint16').type(self._CMD_READ_SIM_SCGC7)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_sim_SCGC6(self, serialized_scgc6):
        command = np.dtype('uint16').type(self._CMD_UPDATE_SIM_SCGC6)
        ARG_STRUCT_SIZE = 8

        serialized_scgc6 = _translate(serialized_scgc6)
        if isinstance(serialized_scgc6, str):
            serialized_scgc6 = map(ord, serialized_scgc6)
        # Argument is an array, so cast to appropriate array type.
        serialized_scgc6 = np.ascontiguousarray(serialized_scgc6, dtype='uint8')
        array_info = pd.DataFrame([serialized_scgc6.shape[0], ],
                                  index=['serialized_scgc6', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_scgc6.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized_scgc6'], ARG_STRUCT_SIZE + array_info.start['serialized_scgc6'], )],
                               dtype=[('serialized_scgc6_length', 'uint32'), ('serialized_scgc6_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def update_sim_SCGC7(self, serialized_scgc7):
        command = np.dtype('uint16').type(self._CMD_UPDATE_SIM_SCGC7)
        ARG_STRUCT_SIZE = 8

        serialized_scgc7 = _translate(serialized_scgc7)
        if isinstance(serialized_scgc7, str):
            serialized_scgc7 = map(ord, serialized_scgc7)
        # Argument is an array, so cast to appropriate array type.
        serialized_scgc7 = np.ascontiguousarray(serialized_scgc7, dtype='uint8')
        array_info = pd.DataFrame([serialized_scgc7.shape[0], ],
                                  index=['serialized_scgc7', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized_scgc7.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized_scgc7'], ARG_STRUCT_SIZE + array_info.start['serialized_scgc7'], )],
                               dtype=[('serialized_scgc7_length', 'uint32'), ('serialized_scgc7_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def free_all(self):
        command = np.dtype('uint16').type(self._CMD_FREE_ALL)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_alloc(self, size):
        command = np.dtype('uint16').type(self._CMD_MEM_ALLOC)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(size, )],
                               dtype=[('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def mem_free(self, address):
        command = np.dtype('uint16').type(self._CMD_MEM_FREE)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, )],
                               dtype=[('address', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_aligned_alloc(self, alignment, size):
        command = np.dtype('uint16').type(self._CMD_MEM_ALIGNED_ALLOC)
        ARG_STRUCT_SIZE = 8
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(alignment, size, )],
                               dtype=[('alignment', 'uint32'), ('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def mem_aligned_free(self, address):
        command = np.dtype('uint16').type(self._CMD_MEM_ALIGNED_FREE)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, )],
                               dtype=[('address', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_aligned_alloc_and_set(self, alignment, data):
        command = np.dtype('uint16').type(self._CMD_MEM_ALIGNED_ALLOC_AND_SET)
        ARG_STRUCT_SIZE = 12

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(alignment, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('alignment', 'uint32'), ('data_length', 'uint32'), ('data_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def mem_cpy_host_to_device(self, address, data):
        command = np.dtype('uint16').type(self._CMD_MEM_CPY_HOST_TO_DEVICE)
        ARG_STRUCT_SIZE = 12

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint32'), ('data_length', 'uint32'), ('data_data', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_cpy_device_to_host(self, address, size):
        command = np.dtype('uint16').type(self._CMD_MEM_CPY_DEVICE_TO_HOST)
        ARG_STRUCT_SIZE = 8
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, size, )],
                               dtype=[('address', 'uint32'), ('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def mem_fill_uint8(self, address, value, size):
        command = np.dtype('uint16').type(self._CMD_MEM_FILL_UINT8)
        ARG_STRUCT_SIZE = 9
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, value, size, )],
                               dtype=[('address', 'uint32'), ('value', 'uint8'), ('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_fill_uint16(self, address, value, size):
        command = np.dtype('uint16').type(self._CMD_MEM_FILL_UINT16)
        ARG_STRUCT_SIZE = 10
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, value, size, )],
                               dtype=[('address', 'uint32'), ('value', 'uint16'), ('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_fill_uint32(self, address, value, size):
        command = np.dtype('uint16').type(self._CMD_MEM_FILL_UINT32)
        ARG_STRUCT_SIZE = 12
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, value, size, )],
                               dtype=[('address', 'uint32'), ('value', 'uint32'), ('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def mem_fill_float(self, address, value, size):
        command = np.dtype('uint16').type(self._CMD_MEM_FILL_FLOAT)
        ARG_STRUCT_SIZE = 12
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, value, size, )],
                               dtype=[('address', 'uint32'), ('value', 'float32'), ('size', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def loop(self):
        command = np.dtype('uint16').type(self._CMD_LOOP)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def last_dma_channel_done(self):
        command = np.dtype('uint16').type(self._CMD_LAST_DMA_CHANNEL_DONE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def attach_dma_interrupt(self, dma_channel):
        command = np.dtype('uint16').type(self._CMD_ATTACH_DMA_INTERRUPT)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(dma_channel, )],
                               dtype=[('dma_channel', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def detach_dma_interrupt(self, dma_channel):
        command = np.dtype('uint16').type(self._CMD_DETACH_DMA_INTERRUPT)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(dma_channel, )],
                               dtype=[('dma_channel', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)







class I2cProxy(I2cProxyMixin, Proxy):
    pass


class SerialProxy(SerialProxyMixin, Proxy):
    pass


