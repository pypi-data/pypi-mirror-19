"""
====================================================
Python for JSON, an E4X like query facility for JSAM
====================================================

P4J allows construction of "xpath" queries in Python using method chaining
and operator overload, bridging the lexical divide between code and query
(Python expressions are used to construct queries).

The basic P4J object is an absolute Path:

        apath = jsam.p4j.abs()

All operations for extending a path return a new object, rather
than modifying the original object, so it's safe to invoke abs()
once,  and reuse the value in multiple places.

Path "steps"
============

Path "steps" can be made using the Python getattr operator ".",
or the array index operator [] (as in JavaScript).  The following
are equivalent::

        path.step
        path['step']

The step ".ANY" matches any label/index (like XPath "*")

The step "[...]" matches any number of labels/indices (like XPath "//")

NOTE: UNLIKE in XPath, array indices appear as steps::
        path.dict.key.array[5]

Predicates
==========

Predicates are "side conditions" to control what nodes are matched
by the current step, and are applied using the "pred" method:

        path = path.pred(Expr)

Predicate Exprs are constructed using Python expressions::
        path
        path RELOP SCALAR
        path.In(LIST_OF_SCALARS)
        path.notin(LIST_OF_SCALARS)
        path.regexp(STRING)
        path.like(STRING)
        Expr & Expr
        Expr | Expr

Predicates notes::
        * Python "and" and "or" cannot be used (cannot be overloaded).
        * Within a predicate "relative" paths are legal, and refer to
          the node matched by the step the predicate is attached to.
        * Relative paths are created with jsam.p4j.rel() (ie; XPath ".")
        * Values from jsam.p4j.rel() like the abs() function, can be reused
          (the relative path base is always relative to the
          step to which the predicate is applied).
        * Multiple predicates can be applied to the same step,
          and function the same as if the '&' operator had been used.
        * A predicate which consists of just a path tests whether
          ANY nodes matched by that path exist.
        * The left hand side of a "relop" within a predicate must be a path.
        * The right hand side of a "relop" within a predicate must be a scalar.
        * Predicates can be applied to paths used in Predicates!

Evaluating P4J Paths
====================

P4J paths are evaluated by passing them to jsam.xpath()
in place of a path string.

Axes
====

An "axis" controls the scope (the direction and depth taken by the step
to locate the next node in a path) can be specified using :: inside
of square brackets::

        path['step'::'AXIS']

Where AXIS is one of::

        ancestor
        ancestor-or-self
        child
        descendant
        descendant-or-self
        following
        following-sibling
        parent
        preceding
        preceding-sibling
        self
        sibling

Inspirations
============

This is very sick, and was inspired by::

jQuery: http://jquery.com/
        A JavaScript library for DOM tree search and manipulation
          using method chaining.

JPath:  http://bluelinecity.com/software/jpath/
        Which implements a JSON XPath in JavaScript using method chaining.

web2py: http://web2py.com/
        Which implements an SQL database query language in Python using
          operator overload.

Implementation
==============

This module creates parse trees compatible with those generated by the
"xparse" XPath parser, and uses the same jsonsqlxpath back end to generate
SQL queries.
"""

__author__ = "Phil Budne"
__revision__ = "$Revision: 1.10 $"
__docformat__ = "restructuredtext"

# have Path declare __get__/__set__/__del__ for modification?!!

import copy
import xparse              # for AxisName; get from common file?

class Predicate(object):
    """superclass for Path Expr"""

    def __nonzero__(self):
        """try to detect and/or operators"""
        # was "Predicate in Boolean context"
        raise P4JException("Use '&' and '|' in Predicate expressions")

    def __call__(self, *args, **kws):
        # catch bad method names
        raise P4JException("Attempt to invoke Predicate")

    def __and__(self, val):     # &
        # XXX check types
        # XXX flatten if either operand is an 'and' Predicate
        return Expr('and', [self._tup(), val._tup()])

    def __or__(self, val):      # |
        # XXX check types
        # XXX flatten if either operand is an 'or' Predicate
        return Expr('or', [self._tup(), val._tup()])

    def not_(self):
        """EXPERIMENTAL: Invert test
           Implement as function?"""
        return ('not', self._tup())

class Expr(Predicate):
    def __cmp__(self, other):
        raise P4JException("Attempt to compare predicate expressions")

    def __init__(self, op, a, b=None):
        self.op = op
        self.a = a
        self.b = b

    def _tup(self):
        return (self.op, self.a, self.b)

class Path(Predicate):
    """mix-in for Paths"""

    def __init__(self, type):
        self.type = type
        self.steps = []

    def _tup(self):
        return (self.type, self.steps)

    def _copy(self):
        return copy.deepcopy(self)

    def __getitem__(self, index):
        """JS [expr] is same as getattr"""
        if isinstance(index, (basestring, int)):
            return self._s(index)

        # [...] is XPath //
        if index is Ellipsis:
            return self._ss()

        # treat [str:str] or [str::str] as axis & name
        if isinstance(index, slice):
            if index.stop is not None and index.step is None:
                return self._s(index.stop, index.start)
            if index.step is not None and index.stop is None:
                return self._s(index.step, index.start)
            # create predicate for start:stop?

        # Experiment: allow [PREDICATE]
        if isinstance(index, Predicate):
            return self.pred(index)

        raise P4JException("Bad index " + index)

    def __getattr__(self, name):
        if isinstance(name, basestring) and name[0:2] == '__':
            return object.__getattr__(self, name)
	if name == 'ANY':
	    name = '*'
        # if bad method name given below, this will recurse!!
        return self._s(name)

    def _s(self, name='*', axis=None):
        """step"""
        if name == '.':
            if axis:
                raise BadAxis("axis with .")
            axis = 'self'
            name = '*'
        elif name == '..':
            if axis:
                raise BadAxis("axis with ..")
            axis = 'parent'
            name = '*'
        elif name == '...':
            if axis:
                raise BadAxis("axis with ...")
            return self._ss()
        if axis is None:
            axis = 'child'
        elif axis not in xparse.AxisName:
            raise BadAxis(axis)

        # XXX check name is valid

        # could peephole optimize here, but better to do it
        # someplace that xparse can benefit from as well...
        new = self._copy()
        new.steps.append( (axis, name, []) )
        return new

    def _ss(self):
        """XPath // (slash slash) -- match zero or more nodes"""

        new = self._copy()
        if len(new.steps) == 0:
            # abbreviated absolute location path: //....
            new.type = 'aalp'
        else:
            new.steps.append( ('descendant-or-self', '*', []) )
        return new

    def pred(self, expr):
        """attach predicate expression to current step"""

        if not isinstance(expr, Predicate):
            raise BadPredicate()

        new = self._copy()
        if len(new.steps) == 0: # no first step?
            new.steps.append( ('child', '*', []) ) # self??

        # append to predicate list of last step
        new.steps[-1][2].append(expr._tup())
        return new

    def _check_scalar(self, val):
        if not isinstance(val, (int, float, bool, basestring)):
            raise BadComparison("expected scalar")

    def _check_string(self, val):
        if not isinstance(val, basestring):
            raise BadComparison("expected string")

    def _check_list(self, val):
        if not isinstance(val, (list, tuple)):
            raise BadComparison("expected list or tuple")

    def __eq__(self, val):
        # XXX allow Expr!!
        self._check_scalar(val)
        return Expr('=', self._tup(), val)

    def __ne__(self, val):
        # XXX allow Expr!!
        self._check_scalar(val)
        return Expr('!=', self._tup(), val)

    def __lt__(self, val):
        self._check_scalar(val)
        return Expr('<', self._tup(), val)

    def __le__(self, val):
        self._check_scalar(val)
        return Expr('<=', self._tup(), val)

    def __gt__(self, val):
        self._check_scalar(val)
        return Expr('>', self._tup(), val)

    def __ge__(self, val):
        self._check_scalar(val)
        return Expr('>=', self._tup(), val)

    def In(self, liszt):
        self._check_list(liszt)
        return Expr('in', self._tup(), liszt)

    def notin(self, liszt):
        self._check_list(liszt)
        return Expr('notin', self, liszt)

    def like(self, string):
        self._check_string(string)
        return Expr('like', self._tup(), string)

    def regexp(self, string):
        self._check_string(string)
        return Expr('regexp', self._tup(), string)

class P4JException(Exception):
    """'Python for JSON' Exception"""

class BadComparison(P4JException):
    """Bad comparison in Predicate"""

################################################################

def abs():
    """create a path/predicate variable with absolute path"""
    return Path('abs')

def rel():
    """create a path/predicate variable relative to the current predicate step"""
    return Path('rel')

################################################################

def test():
    import sys
    v = rel().a
    print v._tup()
    print "================ 2"

    p = v == 'foo'
    print p._tup()

    print "================ 3"

    x = abs()[...].aaa.xxx._s().pred(v)
    print x._tup()

    y = abs()._ss()['aaa']['xxx']['*'].pred(p)
    print y._tup()

    y = abs()._ss()._s('aaa')['xxx'].ANY.pred(p)
    print y._tup()

    print "================"

    z = y.foo
    print z._tup()

    aaa = y[...].foo['sibling'::'b']
    print aaa._tup()

    aaa = y['...']['foo']['sibling':'b']
    print aaa._tup()

    print "================"

    aaa = y['..'].foo
    print aaa._tup()

    print "================"

    q1 = (p | p)
    q2 = (p & p)

    print q1._tup()
    print q2._tup()

    print "================"

    p = v.In(['foo', 'bar'])
    print p._tup()

if __name__ == '__main__':
#    import pdb
#    pdb.set_trace()
    test()
