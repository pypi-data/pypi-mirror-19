# -*- mode: python; coding: utf-8 -*-
# Parser for Simplified XPath for JSON in Python

# This parser is generated by Amit J Patel's YAPPS2
# (Yet Another Python Parser System) see
#       http://theory.stanford.edu/~amitp/Yapps/
# for documentation and updates.

# Adapted from PyXPath 1.0 grammar Copyright 2000, Martin von Löwis
#       http://lists.fourthought.com/pipermail/4suite/2000-December/000956.html
# with updates from PyXML 0.8.4 for YAPPS2
#
# Simplifications inspired by Jesús Zazueta's MicroXPath parser for Antlr:
#       http://www.antlr.org/grammar/1210113624040/MicroXPath.g
#
# Which is based on
#       http://senzhang.netfirms.com/mxpath.htm
# by Sen Zhang <senzhang@yahoo.com>

# NOTE!  The original YAPPS based grammar was modified JUST ENOUGH to
# work with YAPPS2; YAPPS2 enhancements haven't been taken advantage of.

### add:
###     union (at top level)
###     "node tests": (number, string, object, array, boolean, null)?
###     not (function or operator?)???

# shortcuts:

# // == descendant-or-self:*
_ss = ('descendant-or-self', '*', [])

# /./ == /self:*/
_dot = ('self', '*', [])

# /../ == /parent:*/
_dotdot = ('parent', '*', [])

# Helper functions to simplify tree building
def MkOr(exprs):
    if len(exprs)==1:
        return exprs[0]
    return ('or',exprs)

def MkAnd(exprs):
    if len(exprs)==1:
        return exprs[0]
    return ('and',exprs)

# The generated Scanner class is not used, and redefined at the end.
# Therefore, the token definitions are for illustration only, and to
# let YAPPS know what the tokens are.

# The grammar rules attempt to follow the XPath recommendation closely,
# both in textual order and presentation. The following changes have been
# made:
# - left-recursion was replaced with right-recursion
# - left-factorization was applied where necessary
# - semantic values were attached to non-terminals

from string import *
import re
from yappsrt import *

class XPathScanner(Scanner):
    patterns = [
        ("'regexp'", re.compile('regexp')),
        ("'like'", re.compile('like')),
        ("'>='", re.compile('>=')),
        ("'>'", re.compile('>')),
        ("'<='", re.compile('<=')),
        ("'<'", re.compile('<')),
        ("'!='", re.compile('!=')),
        ("'='", re.compile('=')),
        ("'not'", re.compile('not')),
        ("'and'", re.compile('and')),
        ("'or'", re.compile('or')),
        ("'::'", re.compile('::')),
        ("'//'", re.compile('//')),
        ("'/'", re.compile('/')),
        ('Literal', re.compile('"[^"]*"|\'[^\']*')),
        ('Number', re.compile('\\d+(.\\d*)?|.\\d+')),
        ('VariableReference', re.compile('\\$[a-zA-Z_][:a-zA-Z0-9_.-]*')),
        ('AxisName', re.compile('ancestor|ancestor-or-self|child|descendant|descendant-or-self|following|following-sibling|parent|preceding|preceding-sibling|self|sibling')),
        ('Name', re.compile('[a-zA-Z_][a-zA-Z0-9_.-]*')),
        ('LPAREN', re.compile('\\(')),
        ('RPAREN', re.compile('\\)')),
        ('STAR', re.compile('\\*')),
        ('LBRACKET', re.compile('\\[')),
        ('RBRACKET', re.compile('\\]')),
        ('DOT', re.compile('\\.')),
        ('DOTDOT', re.compile('\\.\\.')),
        ('END', re.compile('#')),
    ]
    def __init__(self, str):
        Scanner.__init__(self,None,[],str)

class XPath(Parser):
    def Start(self):
        LocationPath = self.LocationPath()
        END = self._scan('END')
        return LocationPath

    def LocationPath(self):
        _token_ = self._peek()
        if _token_ in ['DOT', 'DOTDOT', 'AxisName', 'STAR', 'Name', 'Number']:
            RelativeLocationPath = self.RelativeLocationPath()
            return ('rel',RelativeLocationPath)
        elif _token_ in ["'/'", "'//'"]:
            AbsoluteLocationPath = self.AbsoluteLocationPath()
            return AbsoluteLocationPath
        else:
            raise SyntaxError(self._pos, 'Could not match LocationPath')

    def AbsoluteLocationPath(self):
        _token_ = self._peek()
        if _token_ == "'/'":
            self._scan("'/'")
            OptRelativeLocationPath = self.OptRelativeLocationPath()
            return ('abs', OptRelativeLocationPath)
        elif _token_ == "'//'":
            self._scan("'//'")
            RelativeLocationPath = self.RelativeLocationPath()
            return ('aalp',RelativeLocationPath)
        else:
            raise SyntaxError(self._pos, 'Could not match AbsoluteLocationPath')

    def OptRelativeLocationPath(self):
        _token_ = self._peek()
        if _token_ not in ["'not'", "'::'", "'//'", "'/'", 'Literal', 'Number', 'VariableReference', 'AxisName', 'Name', 'LPAREN', 'STAR', 'LBRACKET', 'DOT', 'DOTDOT']:
            return None
        elif _token_ not in ["'not'", "'::'", "'//'", "'/'", 'Literal', 'VariableReference', 'LPAREN', 'LBRACKET']:
            RelativeLocationPath = self.RelativeLocationPath()
            return RelativeLocationPath
        else:
            raise SyntaxError(self._pos, 'Could not match OptRelativeLocationPath')

    def RelativeLocationPath(self):
        Step = self.Step()
        RelativeLocationPaths = self.RelativeLocationPaths([Step])
        return RelativeLocationPaths

    def RelativeLocationPaths(self, v):
        _token_ = self._peek()
        if _token_ not in ["'not'", "'::'", "'//'", "'/'", 'Literal', 'Number', 'VariableReference', 'AxisName', 'Name', 'LPAREN', 'STAR', 'LBRACKET', 'DOT', 'DOTDOT']:
            return v
        elif _token_ == "'/'":
            self._scan("'/'")
            Step = self.Step()
            RelativeLocationPaths = self.RelativeLocationPaths(v+[Step])
            return RelativeLocationPaths
        elif _token_ == "'//'":
            self._scan("'//'")
            Step = self.Step()
            RelativeLocationPaths = self.RelativeLocationPaths(v+[_ss, Step])
            return RelativeLocationPaths
        else:
            raise SyntaxError(self._pos, 'Could not match RelativeLocationPaths')

    def Step(self):
        _token_ = self._peek()
        if _token_ in ['AxisName', 'STAR', 'Name', 'Number']:
            AxisSpecifier = self.AxisSpecifier()
            NameTest = self.NameTest()
            Predicates = self.Predicates()
            return (AxisSpecifier,NameTest,Predicates)
        elif _token_ == 'DOT':
            DOT = self._scan('DOT')
            return _dot
        elif _token_ == 'DOTDOT':
            DOTDOT = self._scan('DOTDOT')
            return _dotdot
        else:
            raise SyntaxError(self._pos, 'Could not match Step')

    def Predicates(self):
        _token_ = self._peek()
        if _token_ not in ["'not'", "'::'", 'Literal', 'Number', 'VariableReference', 'AxisName', 'Name', 'LPAREN', 'STAR', 'LBRACKET', 'DOT', 'DOTDOT']:
            return []
        elif _token_ == 'LBRACKET':
            Predicate = self.Predicate()
            Predicates = self.Predicates()
            return [Predicate]+Predicates
        else:
            raise SyntaxError(self._pos, 'Could not match Predicates')

    def AxisSpecifier(self):
        _token_ = self._peek()
        if _token_ in ['STAR', 'Name', 'Number']:
            return 'child'
        elif _token_ == 'AxisName':
            AxisName = self._scan('AxisName')
            self._scan("'::'")
            return AxisName
        else:
            raise SyntaxError(self._pos, 'Could not match AxisSpecifier')

    def NameTest(self):
        _token_ = self._peek()
        if _token_ == 'STAR':
            STAR = self._scan('STAR')
            return '*'
        elif _token_ == 'Name':
            Name = self._scan('Name')
            return Name
        elif _token_ == 'Number':
            Number = self._scan('Number')
            return Number
        else:
            raise SyntaxError(self._pos, 'Could not match NameTest')

    def Predicate(self):
        LBRACKET = self._scan('LBRACKET')
        Expr = self.Expr()
        RBRACKET = self._scan('RBRACKET')
        return Expr

    def Primary(self):
        _token_ = self._peek()
        if _token_ == 'VariableReference':
            VariableReference = self._scan('VariableReference')
            return VariableReference
        elif _token_ == 'Literal':
            Literal = self._scan('Literal')
            return Literal[1:-1]
        elif _token_ == 'Number':
            Number = self._scan('Number')
            return Number
        else:
            raise SyntaxError(self._pos, 'Could not match Primary')

    def Expr(self):
        AndExpr = self.AndExpr()
        OrExprs = self.OrExprs([AndExpr])
        return MkOr(OrExprs)

    def OrExprs(self, v):
        _token_ = self._peek()
        if _token_ == "'or'":
            self._scan("'or'")
            AndExpr = self.AndExpr()
            OrExprs = self.OrExprs(v+[AndExpr])
            return OrExprs
        elif _token_ in ['RBRACKET', 'RPAREN']:
            return v
        else:
            raise SyntaxError(self._pos, 'Could not match OrExprs')

    def AndExpr(self):
        RelationalExpr = self.RelationalExpr()
        AndExprs = self.AndExprs([RelationalExpr])
        return MkAnd(AndExprs)

    def AndExprs(self, v):
        _token_ = self._peek()
        if _token_ == "'and'":
            self._scan("'and'")
            RelationalExpr = self.RelationalExpr()
            AndExprs = self.AndExprs(v+[RelationalExpr])
            return AndExprs
        elif _token_ in ["'or'", 'RBRACKET', 'RPAREN']:
            return v
        else:
            raise SyntaxError(self._pos, 'Could not match AndExprs')

    def RelationalExpr(self):
        _token_ = self._peek()
        if _token_ in ["'/'", "'//'", 'DOT', 'DOTDOT', 'AxisName', 'STAR', 'Name', 'Number']:
            LocationPath = self.LocationPath()
            OptRelOp = self.OptRelOp(LocationPath)
            return OptRelOp
        elif _token_ == 'LPAREN':
            LPAREN = self._scan('LPAREN')
            Expr = self.Expr()
            RPAREN = self._scan('RPAREN')
            return Expr
        elif _token_ == "'not'":
            self._scan("'not'")
            LPAREN = self._scan('LPAREN')
            Expr = self.Expr()
            RPAREN = self._scan('RPAREN')
            return ('not', Expr)
        else:
            raise SyntaxError(self._pos, 'Could not match RelationalExpr')

    def OptRelOp(self, v):
        _token_ = self._peek()
        if _token_ in ["'='", "'!='", "'<'", "'<='", "'>'", "'>='", "'like'", "'regexp'"]:
            RelOp = self.RelOp()
            Primary = self.Primary()
            return (RelOp,v,Primary)
        elif _token_ in ["'and'", "'or'", 'RBRACKET', 'RPAREN']:
            return v
        else:
            raise SyntaxError(self._pos, 'Could not match OptRelOp')

    def RelOp(self):
        _token_ = self._peek()
        if _token_ == "'='":
            self._scan("'='")
            return '='
        elif _token_ == "'!='":
            self._scan("'!='")
            return '!='
        elif _token_ == "'<'":
            self._scan("'<'")
            return '<'
        elif _token_ == "'<='":
            self._scan("'<='")
            return '<='
        elif _token_ == "'>'":
            self._scan("'>'")
            return '>'
        elif _token_ == "'>='":
            self._scan("'>='")
            return '>='
        elif _token_ == "'like'":
            self._scan("'like'")
            return 'like'
        elif _token_ == "'regexp'":
            self._scan("'regexp'")
            return 'regexp'
        else:
            raise SyntaxError(self._pos, 'Could not match RelOp')


def parse(rule, text):
    P = XPath(XPathScanner(text))
    return wrap_error_reporter(P, rule)




# Reimplement scanner, to properly use disambiguation
import re
Name = "[a-zA-Z_](\w|[_.-])*"
XPathExpr="""
  (?P<Literal>\"[^\"]*\"|\'[^\']*\')|
  (?P<Number>\\d+)|
  (?P<VariableReference>\\$""" + Name + """)|
  (?P<Name>"""+Name+""")|
  (?P<LPAREN>\\()|
  (?P<RPAREN>\\))|
  (?P<STAR>\\*)|
  (?P<LBRACKET>\\[)|
  (?P<RBRACKET>\\])|
  (?P<DOTDOT>\\.\\.)|
  (?P<DOT>\\.)|
  (?P<Operator>//|::|>=|<=|!=)|
  (?P<SingleOperator>[<>=/])|
  (?P<ExprWhiteSpace>[ \t\n\r]+)
"""

OperatorName = ['and', 'or', 'like', 'regexp', 'not']
AxisName = ['ancestor', 'ancestor-or-self', 'child',
            'descendant', 'descendant-or-self', 'following',
            'following-sibling', 'parent', 'preceding',
            'preceding-sibling', 'self', 'sibling']

class XPathScanner:
    def __init__(self,input):
        self.tokens = []
        self.input = input
        self.pos = 0
        self.expr = re.compile(XPathExpr,re.VERBOSE)

    def token(self, i, restrict = 0):
        # Return i-th token, checking that it is one of restrict
        res = self.scan(i, restrict)
        if restrict and res[2] not in restrict:
            raise SyntaxError(res[0], "unexpected token "+`res`)
        return res

    def scan(self, i, restrict, prev = 0):

        # Look for i-th token. If prev is non-zero, this is a
        # recursive invocation, and the previous token is a Name
        # Returns the token, stores it in self.tokens, and
        # advances self.pos
        
        if i < len(self.tokens):
            # If we have already looked-ahead, return the token we have.
            return self.tokens[i]
        # Otherwise, make room for next token
        self.tokens.append(None)
        assert len(self.tokens)==i+1

        # If we are at the end of the string, return END token
        if self.pos == len(self.input):
            token = self.pos,self.pos,'END',""
            self.tokens[i] = token
            return token

        # Otherwise, match the regular expression
        m = self.expr.match(self.input, self.pos)
        if not m:
            msg = "Bad Token"
            if restrict:
                msg = "Trying to find one of "+join(restrict,", ")
            raise SyntaxError(self.pos, msg)
        
        if m.group("ExprWhiteSpace") is not None:
            # If we got white space, ignore it and return the next token
            del self.tokens[i]
            self.pos = self.pos + len(m.group("ExprWhiteSpace"))
            return self.scan(i, restrict, prev)

        # Adjust token type according to additional semantic rules
        type = val = None
        for t,v in m.groupdict().items():
            if v is None: continue
            if val:
                raise SyntaxError(self.pos,
                                  "ambiguity:%s could be %s or %s" % (val,type,t))
            type = t
            val = v
        start = self.pos
        stop = self.pos+len(val)
        self.pos = stop

        # If there is a preceding token and the preceding token is not
        # one of ::, (, [, , or an Operator
        if prev or (i>1 and self.tokens[i-1][3] not in ['::','(','[']):
            if type == 'Name' and val in OperatorName:
                # and an Name must be recognized as an OperatorName
                type = repr(str(val))
        if type in ['SingleOperator', 'Operator']:
            type = repr(str(val))
        elif type == 'Name':
            next = self.scan(i+1,0,1)

            # If the two characters following an Name
            # (possibly after intervening ExprWhitespace) are ::
            if type == 'Name' and next[3] == '::' and val in AxisName:
                # then the token must be recognized as an AxisName.
                type = 'AxisName'
        token = start, stop, type, val
        self.tokens[i]=token
        return token

