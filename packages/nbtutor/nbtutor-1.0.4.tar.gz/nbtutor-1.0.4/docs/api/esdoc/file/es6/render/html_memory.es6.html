<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">es6/render/html_memory.es6 | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/data/frame_timeline.es6~FrameTimeline.html">FrameTimeline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/data/heap_history.es6~HeapHistory.html">HeapHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/data/output_history.es6~OutputHistory.html">OutputHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/data/stack_history.es6~StackHistory.html">StackHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/data/stack_timeline.es6~StackTimeline.html">StackTimeline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/data/trace_history.es6~TraceHistory.html">TraceHistory</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">notebook</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/notebook/gutters.es6~GutterMarkers.html">GutterMarkers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/notebook/notebook.es6~VisualizedCell.html">VisualizedCell</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/notebook/toolbar.es6~Toolbar.html">Toolbar</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">render</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/render/html_memory.es6~MemoryModelUI.html">MemoryModelUI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/render/html_timeline.es6~TimelineUI.html">TimelineUI</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">es6/render/html_memory.es6</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint no-unused-vars: 0 */
import {$, d3, uuid, jsplumb} from &quot;nbtutor-deps&quot;;


export class MemoryModelUI{
    constructor(trace_history, d3Root){
        this.trace_history = trace_history;
        this.d3Root = d3Root;
        this.connectors = [];
        this.objects_rendered = [];
        this.jsplumb = jsplumb.getInstance({
            Container: this.d3Root[0],
        });
    }

    _setHover(cls, state){
        d3.select(&quot;.nbtutor-var-object.&quot; + cls).select(&quot;.nbtutor-var-value&quot;)
            .classed(&quot;nbtutor-hover&quot;, state);
        d3.select(&quot;.nbtutor-var-object.&quot; + cls).select(&quot;table&quot;)
            .classed(&quot;nbtutor-hover&quot;, state);
        d3.selectAll(&quot;svg.&quot; + cls).classed(&quot;jtk-hover&quot;, state);
        d3.selectAll(&quot;path.&quot; + cls).classed(&quot;jtk-hover&quot;, state);
    }

    _connectObjects(){
        let that = this;
        this.connectors.map((con) =&gt; {
            let stateMachineConnector = {
                paintStyle: {lineWidth: 2, stroke: &quot;#056&quot;},
                endpoint: &quot;Blank&quot;,
                anchors: [&quot;Right&quot;, &quot;Left&quot;],
                connector: [&quot;Bezier&quot;, {&quot;curviness&quot;: 80}],
                detachable: false,
                overlays: [
                    [&quot;Arrow&quot;, {length: 10, width: 10, location: 1}]
                ],
            };
            stateMachineConnector.cssClass = con.from;
            stateMachineConnector.overlays[0][1].cssClass = con.from;
            if (con.from[0] == &apos;r&apos;){
                stateMachineConnector.anchors = [
                    &quot;Top&quot;, [&quot;Left&quot;, &quot;Right&quot;]
                ];
            }

            d3.select(&quot;#&quot; + con.to).classed(con.from, true);
            this.jsplumb.connect({
                source: con.from,
                target: con.to
            }, stateMachineConnector);
        });
    }

    _createHeapDiv(object){
        let position = object.options.position || &apos;right&apos;;
        let d3Obj = this.d3Root.select(&quot;.nbtutor-heap&quot;)
            .append(&quot;div&quot;)
                .attr(&quot;class&quot;, &quot;nbtutor-heap-row-&quot; + position)
            .append(&quot;div&quot;)
                .attr(&quot;class&quot;, &quot;nbtutor-var-object&quot;)
                .attr(&quot;id&quot;, object.uuid);
        return d3Obj;
    }

    _createPrimitive(object){
        let d3Obj = this._createHeapDiv(object);
        d3Obj.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-var-type&quot;)
            .text(object.type);
        d3Obj.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-var-value&quot;)
            .text(object.value);
    }

    _createSequence(object, tracestep){
        let that = this;
        let heap_history = this.trace_history.heap_history;
        object.values.map((obj) =&gt; {
            let child = heap_history.getObjectById(tracestep, obj.id);
            if (!object.options.inline || child.catagory != &apos;primitive&apos;){
                obj.uuid = &apos;r-&apos; + uuid.v4();
                that._createObject(child, tracestep);
                that.connectors.push({
                    from: obj.uuid,
                    to: child.uuid
                });
            }
        });

        let d3Obj = this._createHeapDiv(object);
        d3Obj.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-var-type&quot;)
            .text(object.type);

        let d3Table = d3Obj.append(&quot;table&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-seq-&quot; + object.type);
        let d3IndRow = d3Table.append(&quot;tr&quot;);
        let d3ValRow = d3Table.append(&quot;tr&quot;);

        // Create sequence index numbers
        let indexes = [];
        for (let i=0; i&lt;object.values.length; i++){
            indexes.push(i);
        }

        // Add an ellipsis to the end of a long sequence
        let ind = object.values.length-1;
        if (object.options.ellipsis){
            if (object.values[ind] === &apos;...&apos;){
                indexes[ind] = &quot;...&quot;;
            } else {
                indexes.push(&quot;...&quot;);
                object.values.push(&quot;...&quot;);
            }
        }

        // Add index numbers
        d3IndRow.selectAll(&quot;td&quot;)
            .data(indexes)
            .enter()
                .append(&quot;td&quot;)
                .attr(&quot;class&quot;, &quot;nbtutor-var-index&quot;)
                .text((d) =&gt; d);

        // Add sequence anchors
        let d3Refs = d3ValRow.selectAll(&quot;td&quot;)
            .data(object.values)
            .enter()
                .append(&quot;td&quot;)
                .attr(&quot;class&quot;, &quot;nbtutor-anchor-from&quot;);

        d3Refs.append(&quot;div&quot;)
            .each(function(d){
                if (object.options.ellipsis &amp;&amp; d === &quot;...&quot;){
                    d3.select(this).text(&quot;...&quot;);
                } else {
                    let child = heap_history.getObjectById(tracestep, d.id);
                    if (object.options.inline &amp;&amp; child.catagory === &apos;primitive&apos;){
                        d3.select(this).text(child.value);
                    } else {
                        d3.select(this).attr(&quot;id&quot;, (d) =&gt; d.uuid);
                    }
                }
            });

        // Toggle mouse hover over ref
        d3Refs.on(&apos;mouseover&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, true);
            that._setHover(d.uuid, true);
        });
        d3Refs.on(&apos;mouseout&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, false);
            that._setHover(d.uuid, false);
        });
    }

    _createArray(object, tracestep){
        let d3Obj = this._createHeapDiv(object);
        d3Obj.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-var-type&quot;)
            .text(object.type);

        let d3Table = d3Obj.append(&quot;table&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-seq-array&quot;);
        let d3IndRow = d3Table.append(&quot;tr&quot;);
        let d3ValRow = d3Table.append(&quot;tr&quot;);

        // Create sequence index numbers
        let indexes = [];
        for (let i=0; i&lt;object.values.length; i++){
            indexes.push(i);
        }

        // Add an ellipsis to the end of a long sequence
        let ind = object.values.length-1;
        if (object.options.ellipsis){
            if (object.values[ind] === &apos;...&apos;){
                indexes[ind] = &quot;...&quot;;
            } else {
                indexes.push(&quot;...&quot;);
                object.values.push(&quot;...&quot;);
            }
        }

        // Add index numbers
        d3IndRow.selectAll(&quot;td&quot;)
            .data(indexes)
            .enter()
                .append(&quot;td&quot;)
                .attr(&quot;class&quot;, &quot;nbtutor-var-index&quot;)
                .text((d) =&gt; d);

        // Add sequence anchors
        d3ValRow.selectAll(&quot;td&quot;)
            .data(object.values)
            .enter()
                .append(&quot;td&quot;)
                    .attr(&quot;class&quot;, &quot;nbtutor-anchor-from&quot;)
                .append(&quot;div&quot;)
                    .text((d) =&gt; d);
    }

    _createKeyValue(object, tracestep){
        let that = this;
        let heap_history = this.trace_history.heap_history;
        object.values.map((obj) =&gt; {
            let key = heap_history.getObjectById(tracestep, obj.key_id);
            if (!object.options.inline_keys || key.catagory != &apos;primitive&apos;){
                obj.key_uuid = &apos;r-&apos; + uuid.v4();
                that._createObject(key, tracestep);
                that.connectors.push({
                    from: obj.key_uuid,
                    to: key.uuid
                });
            }
            let value = heap_history.getObjectById(tracestep, obj.val_id);
            if (!object.options.inline_vals || value.catagory != &apos;primitive&apos;){
                obj.val_uuid = &apos;r-&apos; + uuid.v4();
                that._createObject(value, tracestep);
                that.connectors.push({
                    from: obj.val_uuid,
                    to: value.uuid
                });
            }
        });


        let d3Obj = this._createHeapDiv(object);
        d3Obj.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-var-type&quot;)
            .text(object.type);

        let d3Table = d3Obj.append(&quot;table&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-seq-key-value&quot;);

        // Add an ellipsis to the end of a long sequence
        let ind = object.values.length-1;
        if (object.options.ellipsis){
            if (object.values[ind] != &apos;...&apos;){
                object.values.push(&quot;...&quot;);
            }
        }

        let d3Rows = d3Table.selectAll(&quot;tr&quot;)
            .data(object.values)
            .enter()
                .append(&quot;tr&quot;);

        let d3Keys = d3Rows.append(&quot;td&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-anchor-from&quot;);
        let d3Vals = d3Rows.append(&quot;td&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-anchor-from&quot;);

        d3Keys.append(&quot;div&quot;)
            .each(function(d){
                if (object.options.ellipsis &amp;&amp; d === &quot;...&quot;){
                    d3.select(this).text(&quot;...&quot;);
                } else {
                    let key = heap_history.getObjectById(tracestep, d.key_id);
                    if (object.options.inline_keys &amp;&amp; key.catagory === &apos;primitive&apos;){
                        d3.select(this).text(key.value);
                    } else {
                        d3.select(this).attr(&quot;id&quot;, (d) =&gt; d.key_uuid);
                    }
                }
            });

        d3Vals.append(&quot;div&quot;)
            .each(function(d){
                if (object.options.ellipsis &amp;&amp; d === &quot;...&quot;){
                    d3.select(this).text(&quot;...&quot;);
                } else {
                    let value = heap_history.getObjectById(tracestep, d.val_id);
                    if (object.options.inline_vals &amp;&amp; value.catagory === &apos;primitive&apos;){
                        d3.select(this).text(value.value);
                    } else {
                        d3.select(this).attr(&quot;id&quot;, (d) =&gt; d.val_uuid);
                    }
                }
            });

        // Toggle mouse hover over ref
        d3Keys.on(&apos;mouseover&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, true);
            that._setHover(d.key_uuid, true);
        });
        d3Keys.on(&apos;mouseout&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, false);
            that._setHover(d.key_uuid, false);
        });
        d3Vals.on(&apos;mouseover&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, true);
            that._setHover(d.val_uuid, true);
        });
        d3Vals.on(&apos;mouseout&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, false);
            that._setHover(d.val_uuid, false);
        });
    }

    _createObject(object, tracestep){
        if (this.objects_rendered.indexOf(object.uuid) &gt;= 0){
            return;
        }

        this.objects_rendered.push(object.uuid);
        switch (object.catagory){
            case &quot;primitive&quot;:
                this._createPrimitive(object);
                break;
            case &quot;sequence&quot;:
                this._createSequence(object, tracestep);
                break;
            case &quot;array&quot;:
                this._createArray(object, tracestep);
                break;
            case &quot;key-value&quot;:
                this._createKeyValue(object, tracestep);
                break;
            default:
                this._createPrimitive({
                    uuid: object.uuid,
                    type: object.type,
                    options: object.options,
                    value: &apos;OBJECT&apos;,
                });
        }
    }

    create(tracestep){
        // First destroy any previous visualization
        this.destroy();

        // Init parent div
        this.d3Root.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-stack&quot;);
        this.d3Root.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-heap&quot;);

        let stack_history = this.trace_history.stack_history;
        let heap_history = this.trace_history.heap_history;
        let stack_frames = stack_history.getStackFrames(tracestep);

        // Create tables for each frame
        let d3Frames = this.d3Root.select(&quot;.nbtutor-stack&quot;).selectAll(&quot;div&quot;)
            .data(stack_frames, (d) =&gt; d.uuid)
            .enter()
                .append(&quot;div&quot;)
                .attr(&quot;class&quot;, &quot;nbtutor-frame&quot;);

        d3Frames.append(&quot;table&quot;)
            .attr(&quot;id&quot;, (d) =&gt; d.uuid)
            .append(&quot;thead&quot;)
            .append(&quot;tr&quot;)
            .append(&quot;th&quot;)
                .attr(&quot;colspan&quot;, 2)
                .text((d) =&gt; d.name);
        d3Frames.select(&quot;table&quot;).append(&quot;tbody&quot;);
        d3Frames.select(&quot;table&quot;).append(&quot;tfoot&quot;);

        // Add names to each frame
        let d3Names = d3Frames.select(&quot;tbody&quot;).selectAll(&quot;tr&quot;)
            .data((d) =&gt; {
                return d.vars.map((v) =&gt; {
                    return {object: v, options: d.options};
                });
            }, (d) =&gt; d.object.name)
            .enter()
                .append(&quot;tr&quot;);

        let that = this;
        d3Names.append(&quot;td&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-var-name&quot;)
            .text((d) =&gt; d.object.name);

        d3Names.append(&quot;td&quot;)
            .attr(&quot;class&quot;, &quot;nbtutor-anchor-from&quot;)
            .append(&quot;div&quot;)
                .attr(&quot;id&quot;, (d) =&gt; d.object.uuid)
            .each(function(d){
                let object = heap_history.getObjectById(tracestep, d.object.id);
                if (d.options.inline &amp;&amp; object.catagory === &apos;primitive&apos;){
                    d3.select(this).text(object.value);
                } else {
                    that._createObject(object, tracestep);
                    that.connectors.push({
                        from: d.object.uuid,
                        to: object.uuid
                    });
                }
            });

        // Create connector lines
        this._connectObjects();

        // Toggle active frame
        let d3Tables = this.d3Root.select(&quot;.nbtutor-stack&quot;).selectAll(&quot;table&quot;);
        d3Tables.classed(&quot;nbtutor-active&quot;, false);
        d3.select(d3Tables[0].pop()).classed(&quot;nbtutor-active&quot;, true);

        // Toggle mouse hover over name
        d3Names.on(&apos;mouseover&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, true);
            that._setHover(d.object.uuid, true);
        });
        d3Names.on(&apos;mouseout&apos;, function(d){
            d3.select(this).classed(&quot;nbtutor-hover&quot;, false);
            that._setHover(d.object.uuid, false);
        });

        $(window).resize(function(){
            that.jsplumb.repaintEverything();
        });
    }

    destroy(){
        this.jsplumb.empty(this.d3Root[0]);
        this.d3Root.selectAll(&quot;div&quot;).remove();
        this.connectors = [];
        this.objects_rendered = [];
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
