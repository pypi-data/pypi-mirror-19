Metadata-Version: 1.1
Name: schedula
Version: 0.1.0.dev1
Summary: Produce a plan that dispatches calls based on a graph of functions, satisfying data dependencies.
Home-page: https://github.com/vinci1it2000/schedula
Author: Vincenzo Arcidiacono
Author-email: vinci1it2000@gmail.com
License: EUPL 1.1+
Download-URL: https://github.com/vinci1it2000/schedula/tarball/v0.1.0.dev1
Description: 
        schedula: An intelligent function scheduler
        *******************************************
        
        [image: Latest Version in PyPI][image] [image: Travis build
        status][image] [image: Apveyor build status][image] [image: Code
        coverage][image] [image: Documentation status][image] [image:
        Dependencies up-to-date?][image] [image: Downloads][image] [image:
        Issues count][image] [image: Supported Python versions][image] [image:
        Project License][image]
        
        release:
           0.1.0.dev1
        
        date:
           2017-01-20 20:00:00
        
        repository:
           https://github.com/vinci1it2000/schedula
        
        pypi-repo:
           https://pypi.org/project/schedula/
        
        docs:
           http://schedula.readthedocs.io/
        
        wiki:
           https://github.com/vinci1it2000/schedula/wiki/
        
        download:
           http://github.com/vinci1it2000/schedula/releases/
        
        keywords:
           scheduling, dispatch, dataflow, processing, calculation,
           dependencies, scientific, engineering, simulink, graph theory
        
        developers:
           * Vincenzo Arcidiacono
             <vincenzo.arcidiacono@ext.jrc.ec.europa.eu>
        
           * Kostis Anagnostopoulos
             <konstantinos.anagnostopoulos@ext.jrc.ec.europa.eu>
        
        license:
           EUPL 1.1+
        
        
        What is schedula?
        =================
        
        Schedula implements a intelligent function scheduler, which selects
        and executes functions. The order (workflow) is calculated from the
        provided inputs and the requested outputs. A function is executed when
        all its dependencies (i.e., inputs, input domain) are satisfied and
        when at least one of its outputs has to be calculated.
        
        Note: Schedula is performing the runtime selection of the minimum-
          workflow to be invoked. A workflow describes the overall process -
          i.e., the order of function execution - and it is defined by a
          directed acyclic graph (DAG). The minimum-workflow is the DAG where
          each output is calculated using the shortest path from the provided
          inputs. The path is calculated on the basis of a weighed directed
          graph (data-flow diagram) with a modified Dijkstra algorithm.
        
        
        Installation
        ============
        
        To install it use (with root privileges):
        
           $ pip install schedula --process-dependency-links
        
        Or download the last git version and use (with root privileges):
        
           $ python setup.py install
        
        
        Why may I use schedula?
        =======================
        
        Imagine we have a system of interdependent functions - i.e. the inputs
        of a function are the output for one or more function(s), and we do
        not know which input the user will provide and which output will
        request. With a normal scheduler you would have to code all possible
        implementations. I'm bored to think and code all possible combinations
        of inputs and outputs from a model.
        
        
        Solution
        --------
        
        Schedula allows to write a simple model ("Dispatcher()") with just the
        basic functions, then the "Dispatcher()" will select and execute the
        proper functions for the given inputs and the requested outputs.
        Moreover, schedula provides a flexible framework for structuring code.
        It allows to extract sub-models from a bigger one.
        
        Note: A successful application is CO_2MPAS, where schedula has been
          used to model an entire vehicle.
        
        
        Very simple example
        ===================
        
        Let's assume that we have to extract some filesystem attributes and we
        do not know which inputs the user will provide. The code below shows
        how to create a "Dispatcher()" adding the functions that define your
        system. Note that with this simple system the maximum number of inputs
        combinations is 31 ((2^n - 1), where *n* is the number of data).
        
           >>> import schedula
           >>> import os.path as osp
           >>> dsp = schedula.Dispatcher()
           >>> dsp.add_function(function=osp.split, inputs=['path'],
           ...                  outputs=['dirname', 'basename'])
           'split'
           >>> dsp.add_function(function=osp.splitext, inputs=['basename'],
           ...                  outputs=['fname', 'suffix'])
           'splitext'
        
           [graph]
        
        Tip: You can explore the diagram by clicking on it.
        
        Note: For more details how to created a "Dispatcher()" see:
          "add_data()", "add_function()", "add_dispatcher()", "SubDispatch()",
          "SubDispatchFunction()", "SubDispatchPipe()", and "DFun()".
        
        The next step to calculate the outputs would be just to run the
        "dispatch()" method. You can invoke it with just the inputs, so it
        will calculate all reachable outputs:
        
           >>> inputs = {'path': 'schedula/_version.py'}
           >>> o = dsp.dispatch(inputs=inputs)
           >>> o
           Solution([('path', 'schedula/_version.py'),
                     ('basename', '_version.py'),
                     ('dirname', 'schedula'),
                     ('fname', '_version'),
                     ('suffix', '.py')])
        
           [graph]
        
        or you can set also the outputs, so the dispatch will stop when it
        will find all outputs:
        
           >>> o = dsp.dispatch(inputs=inputs, outputs=['basename'])
           >>> o
           Solution([('path', 'schedula/_version.py'), ('basename', '_version.py')])
        
           [graph]
        
        
        Advanced example (circular system)
        ==================================
        
        Systems of interdependent functions can be described by "graphs" and
        they might contains **circles**. This kind of system can not be
        resolved by a normal scheduler.
        
        Suppose to have a system of sequential functions in circle - i.e., the
        input of a function is the output of the previous function. The
        maximum number of input and output permutations is (2^n - 1)^2, where
        *n* is the number of functions. Thus, with a normal scheduler you have
        to code all possible implementations, so (2^n - 1)^2 functions
        (IMPOSSIBLE!!!).
        
        Schedula will simplify your life. You just create a "Dispatcher()",
        that contains all functions that link your data:
        
           >>> import schedula
           >>> dsp = schedula.Dispatcher()
           >>> plus, minus = lambda x: x + 1, lambda x: x - 1
           >>> n = j = 6
           >>> for i in range(1, n + 1):
           ...     func = plus if i < (n / 2 + 1) else minus
           ...     f = dsp.add_function('f%d' % i, func, ['v%d' % j], ['v%d' % i])
           ...     j = i
        
           [graph]
        
        Then it will handle all possible combination of inputs and outputs
        ((2^n - 1)^2) just invoking the "dispatch()" method, as follows:
        
           >>> out = dsp.dispatch(inputs={'v1': 0, 'v4': 1}, outputs=['v2', 'v6'])
           >>> out
           Solution([('v1', 0), ('v4', 1), ('v2', 1), ('v5', 0), ('v6', -1)])
        
           [graph]
        
        
        Sub-system extraction
        ---------------------
        
        Schedula allows to extract sub-models from a model. This could be done
        with the "shrink_dsp()" method, as follows:
        
           >>> sub_dsp = dsp.shrink_dsp(('v1', 'v3', 'v5'), ('v2', 'v4', 'v6'))
        
           [graph]
        
        Note: For more details how to extract a sub-model see:
          "get_sub_dsp()", "get_sub_dsp_from_workflow()", "SubDispatch()",
          "SubDispatchFunction()", and "SubDispatchPipe()".
        
        
        Next moves
        ==========
        
        Things yet to do include a mechanism to allow the execution of
        functions in parallel.
        
Keywords: python,utility,library,data,processing,calculation,dependencies,resolution,scientific,engineering,dispatch,scheduling,simulink,graphviz
Platform: UNKNOWN
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Development Status :: 3 - Alpha
Classifier: Natural Language :: English
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: European Union Public Licence 1.1 (EUPL 1.1)
Classifier: Operating System :: MacOS :: MacOS X
Classifier: Operating System :: Microsoft :: Windows
Classifier: Operating System :: POSIX
Classifier: Operating System :: Unix
Classifier: Operating System :: OS Independent
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Information Analysis
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Utilities
